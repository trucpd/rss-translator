{
  "last_updated": "2025-03-08T10:09:16.942840",
  "entries": [
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Spotlight on SIG etcd",
      "link": "https://kubernetes.io/blog/2025/03/04/sig-etcd-spotlight/",
      "published": "Tue, 04 Mar 2025 00:00:00 +0000",
      "summary": "<p>In this SIG etcd spotlight we talked with <a href=\"https://github.com/jmhbnz\">James Blair</a>, <a href=\"https://github.com/serathius\">Marek\nSiarkowicz</a>, <a href=\"https://github.com/wenjiaswe\">Wenjia Zhang</a>, and\n<a href=\"https://github.com/ahrtr\">Benjamin Wang</a> to learn a bit more about this Kubernetes Special Interest\nGroup.</p>\n<h2 id=\"introducing-sig-etcd\">Introducing SIG etcd</h2>\n<p><strong>Frederico: Hello, thank you for the time! Let’s start with some introductions, could you tell us a\nbit about yourself, your role and how you got involved in Kubernetes.</strong></p>\n<p><strong>Benjamin:</strong> Hello, I am Benjamin. I am a SIG etcd Tech Lead and one of the etcd maintainers. I\nwork for VMware, which is part of the Broadcom group. I got involved in Kubernetes &amp; etcd &amp; CSI\n(<a href=\"https://github.com/container-storage-interface/spec/blob/master/spec.md\">Container Storage Interface</a>)\nbecause of work and also a big passion for open source. I have been working on Kubernetes &amp; etcd\n(and also CSI) since 2020.</p>\n<p><strong>James:</strong> Hey team, I’m James, a co-chair for SIG etcd and etcd maintainer. I work at Red Hat as a\nSpecialist Architect helping people adopt cloud native technology. I got involved with the\nKubernetes ecosystem in 2019. Around the end of 2022 I noticed how the etcd community and project\nneeded help so started contributing as often as I could. There is a saying in our community that\n&quot;you come for the technology, and stay for the people&quot;: for me this is absolutely real, it’s been a\nwonderful journey so far and I’m excited to support our community moving forward.</p>\n<p><strong>Marek:</strong> Hey everyone, I'm Marek, the SIG etcd lead. At Google, I lead the GKE etcd team, ensuring\na stable and reliable experience for all GKE users. My Kubernetes journey began with <a href=\"https://github.com/kubernetes/community/tree/master/sig-instrumentation\">SIG\nInstrumentation</a>, where I\ncreated and led the <a href=\"https://kubernetes.io/blog/2020/09/04/kubernetes-1-19-introducing-structured-logs/\">Kubernetes Structured Logging effort</a>.<br />\nI'm still the main project lead for <a href=\"https://kubernetes-sigs.github.io/metrics-server/\">Kubernetes Metrics Server</a>,\nproviding crucial signals for autoscaling in Kubernetes. I started working on etcd 3 years ago,\nright around the 3.5 release. We faced some challenges, but I'm thrilled to see etcd now the most\nscalable and reliable it's ever been, with the highest contribution numbers in the project's\nhistory. I'm passionate about distributed systems, extreme programming, and testing.</p>\n<p><strong>Wenjia:</strong> Hi there, my name is Wenjia, I am the co-chair of SIG etcd and one of the etcd\nmaintainers. I work at Google as an Engineering Manager, working on GKE (Google Kubernetes Engine)\nand GDC (Google Distributed Cloud). I have been working in the area of open source Kubernetes and\netcd since the Kubernetes v1.10 and etcd v3.1 releases. I got involved in Kubernetes because of my\njob, but what keeps me in the space is the charm of the container orchestration technology, and more\nimportantly, the awesome open source community.</p>\n<h2 id=\"becoming-a-kubernetes-special-interest-group-sig\">Becoming a Kubernetes Special Interest Group (SIG)</h2>\n<p><strong>Frederico: Excellent, thank you. I'd like to start with the origin of the SIG itself: SIG etcd is\na very recent SIG, could you quickly go through the history and reasons behind its creation?</strong></p>\n<p><strong>Marek</strong>: Absolutely! SIG etcd was formed because etcd is a critical component of Kubernetes,\nserving as its data store. However, etcd was facing challenges like maintainer turnover and\nreliability issues. <a href=\"https://etcd.io/blog/2023/introducing-sig-etcd/\">Creating a dedicated SIG</a>\nallowed us to focus on addressing these problems, improving development and maintenance processes,\nand ensuring etcd evolves in sync with the cloud-native landscape.</p>\n<p><strong>Frederico: And has becoming a SIG worked out as expected? Better yet, are the motivations you just\ndescribed being addressed, and to what extent?</strong></p>\n<p><strong>Marek</strong>: It's been a positive change overall. Becoming a SIG has brought more structure and\ntransparency to etcd's development. We've adopted Kubernetes processes like KEPs\n(<a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/README.md\">Kubernetes Enhancement Proposals</a>\nand PRRs (<a href=\"https://github.com/kubernetes/community/blob/master/sig-architecture/production-readiness.md\">Production Readiness Reviews</a>,\nwhich has improved our feature development and release cycle.</p>\n<p><strong>Frederico: On top of those, what would you single out as the major benefit that has resulted from\nbecoming a SIG?</strong></p>\n<p><strong>Marek</strong>: The biggest benefits for me was adopting Kubernetes testing infrastructure, tools like\n<a href=\"https://docs.prow.k8s.io/\">Prow</a> and <a href=\"https://testgrid.k8s.io/\">TestGrid</a>. For large projects like\netcd there is just no comparison to the default GitHub tooling. Having known, easy to use, clear\ntools is a major boost to the etcd as it makes it much easier for Kubernetes contributors to also\nhelp etcd.</p>\n<p><strong>Wenjia</strong>: Totally agree, while challenges remain, the SIG structure provides a solid foundation\nfor addressing them and ensuring etcd's continued success as a critical component of the Kubernetes\necosystem.</p>\n<p>The positive impact on the community is another crucial aspect of SIG etcd's success that I’d like\nto highlight. The Kubernetes SIG structure has created a welcoming environment for etcd\ncontributors, leading to increased participation from the broader Kubernetes community. We have had\ngreater collaboration with other SIGs like <a href=\"https://github.com/kubernetes/community/blob/master/sig-api-machinery/README.md\">SIG API\nMachinery</a>,\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-scalability\">SIG Scalability</a>,\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-scalability\">SIG Testing</a>,\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-cluster-lifecycle\">SIG Cluster Lifecycle</a>, etc.</p>\n<p>This collaboration helps ensure etcd's development aligns with the needs of the wider Kubernetes\necosystem. The formation of the <a href=\"https://github.com/kubernetes/community/blob/master/wg-etcd-operator/README.md\">etcd Operator Working Group</a>\nunder the joint effort between SIG etcd and SIG Cluster Lifecycle exemplifies this successful\ncollaboration, demonstrating a shared commitment to improving etcd's operational aspects within\nKubernetes.</p>\n<p><strong>Frederico: Since you mentioned collaboration, have you seen changes in terms of contributors and\ncommunity involvement in recent months?</strong></p>\n<p><strong>James</strong>: Yes -- as showing in our\n<a href=\"https://etcd.devstats.cncf.io/d/23/prs-authors-repository-groups?orgId=1&amp;var-period=m&amp;var-repogroup_name=All&amp;from=1422748800000&amp;to=1738454399000\">unique PR author data</a>\nwe recently hit an all time high in March and are trending in a positive direction:</p>\n<figure>\n<img alt=\"Unique PR author data stats\" src=\"https://kubernetes.io/blog/2025/03/04/sig-etcd-spotlight/stats.png\" />\n</figure>\n<p>Additionally, looking at our\n<a href=\"https://etcd.devstats.cncf.io/d/74/contributions-chart?orgId=1&amp;from=1422748800000&amp;to=1738454399000&amp;var-period=m&amp;var-metric=contributions&amp;var-repogroup_name=All&amp;var-country_name=All&amp;var-company_name=All&amp;var-company=all\">overall contributions across all etcd project repositories</a>\nwe are also observing a positive trend showing a resurgence in etcd project activity:</p>\n<figure>\n<img alt=\"Overall contributions stats\" src=\"https://kubernetes.io/blog/2025/03/04/sig-etcd-spotlight/stats2.png\" />\n</figure>\n<h2 id=\"the-road-ahead\">The road ahead</h2>\n<p><strong>Frederico: That's quite telling, thank you. In terms of the near future, what are the current\npriorities for SIG etcd?</strong></p>\n<p><strong>Marek</strong>: Reliability is always top of mind -– we need to make sure etcd is rock-solid. We're also\nworking on making etcd easier to use and manage for operators. And we have our sights set on making\netcd a viable standalone solution for infrastructure management, not just for Kubernetes. Oh, and of\ncourse, scaling -– we need to ensure etcd can handle the growing demands of the cloud-native world.</p>\n<p><strong>Benjamin</strong>: I agree that reliability should always be our top guiding principle. We need to ensure\nnot only correctness but also compatibility. Additionally, we should continuously strive to improve\nthe understandability and maintainability of etcd. Our focus should be on addressing the pain points\nthat the community cares about the most.</p>\n<p><strong>Frederico: Are there any specific SIGs that you work closely with?</strong></p>\n<p><strong>Marek</strong>: SIG API Machinery, for sure – they own the structure of the data etcd stores, so we're\nconstantly working together. And SIG Cluster Lifecycle – etcd is a key part of Kubernetes clusters,\nso we collaborate on the newly created etcd operator Working group.</p>\n<p><strong>Wenjia</strong>: Other than SIG API Machinery and SIG Cluster Lifecycle that Marek mentioned above, SIG\nScalability and SIG Testing is another group that we work closely with.</p>\n<p><strong>Frederico: In a more general sense, how would you list the key challenges for SIG etcd in the\nevolving cloud native landscape?</strong></p>\n<p><strong>Marek</strong>: Well, reliability is always a challenge when you're dealing with critical data. The\ncloud-native world is evolving so fast that scaling to meet those demands is a constant effort.</p>\n<h2 id=\"getting-involved\">Getting involved</h2>\n<p><strong>Frederico: We're almost at the end of our conversation, but for those interested in in etcd, how\ncan they get involved?</strong></p>\n<p><strong>Marek</strong>: We'd love to have them! The best way to start is to join our\n<a href=\"https://github.com/kubernetes/community/blob/master/sig-etcd/README.md#meetings\">SIG etcd meetings</a>,\nfollow discussions on the <a href=\"https://groups.google.com/g/etcd-dev\">etcd-dev mailing list</a>, and check\nout our <a href=\"https://github.com/etcd-io/etcd/issues\">GitHub issues</a>. We're always looking for people to\nreview proposals, test code, and contribute to documentation.</p>\n<p><strong>Wenjia</strong>: I love this question 😀 . There are numerous ways for people interested in contributing\nto SIG etcd to get involved and make a difference. Here are some key areas where you can help:</p>\n<p><strong>Code Contributions</strong>:</p>\n<ul>\n<li><em>Bug Fixes</em>: Tackle existing issues in the etcd codebase. Start with issues labeled &quot;good first\nissue&quot; or &quot;help wanted&quot; to find tasks that are suitable for newcomers.</li>\n<li><em>Feature Development</em>: Contribute to the development of new features and enhancements. Check the\netcd roadmap and discussions to see what's being planned and where your skills might fit in.</li>\n<li><em>Testing and Code Reviews</em>: Help ensure the quality of etcd by writing tests, reviewing code\nchanges, and providing feedback.</li>\n<li><em>Documentation</em>: Improve <a href=\"https://etcd.io/docs/\">etcd's documentation</a> by adding new content,\nclarifying existing information, or fixing errors. Clear and comprehensive documentation is\nessential for users and contributors.</li>\n<li><em>Community Support</em>: Answer questions on forums, mailing lists, or <a href=\"https://kubernetes.slack.com/archives/C3HD8ARJ5\">Slack channels</a>.\nHelping others understand and use etcd is a valuable contribution.</li>\n</ul>\n<p><strong>Getting Started</strong>:</p>\n<ul>\n<li><em>Join the community</em>: Start by joining the etcd community on Slack,\nattending SIG meetings, and following the mailing lists. This will\nhelp you get familiar with the project, its processes, and the\npeople involved.</li>\n<li><em>Find a mentor</em>: If you're new to open source or etcd, consider\nfinding a mentor who can guide you and provide support. Stay tuned!\nOur first cohort of mentorship program was very successful. We will\nhave a new round of mentorship program coming up.</li>\n<li><em>Start small</em>: Don't be afraid to start with small contributions. Even\nfixing a typo in the documentation or submitting a simple bug fix\ncan be a great way to get involved.</li>\n</ul>\n<p>By contributing to etcd, you'll not only be helping to improve a\ncritical piece of the cloud-native ecosystem but also gaining valuable\nexperience and skills. So, jump in and start contributing!</p>\n<p><strong>Frederico: Excellent, thank you. Lastly, one piece of advice that\nyou'd like to give to other newly formed SIGs?</strong></p>\n<p><strong>Marek</strong>: Absolutely! My advice would be to embrace the established\nprocesses of the larger community, prioritize collaboration with other\nSIGs, and focus on building a strong community.</p>\n<p><strong>Wenjia</strong>: Here are some tips I myself found very helpful in my OSS\njourney:</p>\n<ul>\n<li><em>Be patient</em>: Open source development can take time. Don't get\ndiscouraged if your contributions aren't accepted immediately or if\nyou encounter challenges.</li>\n<li><em>Be respectful</em>: The etcd community values collaboration and\nrespect. Be mindful of others' opinions and work together to achieve\ncommon goals.</li>\n<li><em>Have fun</em>: Contributing to open source should be\nenjoyable. Find areas that interest you and contribute in ways that\nyou find fulfilling.</li>\n</ul>\n<p><strong>Frederico: A great way to end this spotlight, thank you all!</strong></p>\n<hr />\n<p>For more information and resources, please take a look at :</p>\n<ol>\n<li>etcd website: <a href=\"https://etcd.io/\">https://etcd.io/</a></li>\n<li>etcd GitHub repository: <a href=\"https://github.com/etcd-io/etcd\">https://github.com/etcd-io/etcd</a></li>\n<li>etcd community: <a href=\"https://etcd.io/community/\">https://etcd.io/community/</a></li>\n</ol>",
      "timestamp": 1741428556.9202058,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "NFTables mode for kube-proxy",
      "link": "https://kubernetes.io/blog/2025/02/28/nftables-kube-proxy/",
      "published": "Fri, 28 Feb 2025 00:00:00 +0000",
      "summary": "<p>A new nftables mode for kube-proxy was introduced as an alpha feature\nin Kubernetes 1.29. Currently in beta, it is expected to be GA as of\n1.33. The new mode fixes long-standing performance problems with the\niptables mode and all users running on systems with reasonably-recent\nkernels are encouraged to try it out. (For compatibility reasons, even\nonce nftables becomes GA, iptables will still be the <em>default</em>.)</p>\n<h2 id=\"why-nftables-part-1-data-plane-latency\">Why nftables? Part 1: data plane latency</h2>\n<p>The iptables API was designed for implementing simple firewalls, and\nhas problems scaling up to support Service proxying in a large\nKubernetes cluster with tens of thousands of Services.</p>\n<p>In general, the ruleset generated by kube-proxy in iptables mode has a\nnumber of iptables rules proportional to the sum of the number of\nServices and the total number of endpoints. In particular, at the top\nlevel of the ruleset, there is one rule to test each possible Service\nIP (and port) that a packet might be addressed to:</p>\n<pre tabindex=\"0\"><code># If the packet is addressed to 172.30.0.41:80, then jump to the chain\n# KUBE-SVC-XPGD46QRK7WJZT7O for further processing\n-A KUBE-SERVICES -m comment --comment \"namespace1/service1:p80 cluster IP\" -m tcp -p tcp -d 172.30.0.41 --dport 80 -j KUBE-SVC-XPGD46QRK7WJZT7O\n# If the packet is addressed to 172.30.0.42:443, then...\n-A KUBE-SERVICES -m comment --comment \"namespace2/service2:p443 cluster IP\" -m tcp -p tcp -d 172.30.0.42 --dport 443 -j KUBE-SVC-GNZBNJ2PO5MGZ6GT\n# etc...\n-A KUBE-SERVICES -m comment --comment \"namespace3/service3:p80 cluster IP\" -m tcp -p tcp -d 172.30.0.43 --dport 80 -j KUBE-SVC-X27LE4BHSL4DOUIK\n</code></pre><p>This means that when a packet comes in, the time it takes the kernel\nto check it against all of the Service rules is <strong>O(n)</strong> in the number\nof Services. As the number of Services increases, both the average and\nthe worst-case latency for the first packet of a new connection\nincreases (with the difference between best-case, average, and\nworst-case being mostly determined by whether a given Service IP\naddress appears earlier or later in the <code>KUBE-SERVICES</code> chain).</p>\n<figure>\n<img alt=\"kube-proxy iptables first packet latency, at various percentiles, in clusters of various sizes\" src=\"https://kubernetes.io/blog/2025/02/28/nftables-kube-proxy/iptables-only.svg\" />\n</figure>\n<p>By contrast, with nftables, the normal way to write a ruleset like\nthis is to have a <em>single</em> rule, using a &quot;verdict map&quot; to do the\ndispatch:</p>\n<pre tabindex=\"0\"><code>table ip kube-proxy {\n# The service-ips verdict map indicates the action to take for each matching packet.\nmap service-ips {\ntype ipv4_addr . inet_proto . inet_service : verdict\ncomment \"ClusterIP, ExternalIP and LoadBalancer IP traffic\"\nelements = { 172.30.0.41 . tcp . 80 : goto service-ULMVA6XW-namespace1/service1/tcp/p80,\n172.30.0.42 . tcp . 443 : goto service-42NFTM6N-namespace2/service2/tcp/p443,\n172.30.0.43 . tcp . 80 : goto service-4AT6LBPK-namespace3/service3/tcp/p80,\n... }\n}\n# Now we just need a single rule to process all packets matching an\n# element in the map. (This rule says, \"construct a tuple from the\n# destination IP address, layer 4 protocol, and destination port; look\n# that tuple up in \"service-ips\"; and if there's a match, execute the\n# associated verdict.)\nchain services {\nip daddr . meta l4proto . th dport vmap @service-ips\n}\n...\n}\n</code></pre><p>Since there's only a single rule, with a roughly <strong>O(1)</strong> map lookup,\npacket processing time is more or less constant regardless of cluster\nsize, and the best/average/worst cases are very similar:</p>\n<figure>\n<img alt=\"kube-proxy nftables first packet latency, at various percentiles, in clusters of various sizes\" src=\"https://kubernetes.io/blog/2025/02/28/nftables-kube-proxy/nftables-only.svg\" />\n</figure>\n<p>But note the huge difference in the vertical scale between the\niptables and nftables graphs! In the clusters with 5000 and 10,000\nServices, the p50 (average) latency for nftables is about the same as\nthe p01 (approximately best-case) latency for iptables. In the 30,000\nService cluster, the p99 (approximately worst-case) latency for\nnftables manages to beat out the p01 latency for iptables by a few\nmicroseconds! Here's both sets of data together, but you may have to\nsquint to see the nftables results!:</p>\n<figure>\n<img alt=\"kube-proxy iptables-vs-nftables first packet latency, at various percentiles, in clusters of various sizes\" src=\"https://kubernetes.io/blog/2025/02/28/nftables-kube-proxy/iptables-vs-nftables.svg\" />\n</figure>\n<h2 id=\"why-nftables-part-2-control-plane-latency\">Why nftables? Part 2: control plane latency</h2>\n<p>While the improvements to data plane latency in large clusters are\ngreat, there's another problem with iptables kube-proxy that often\nkeeps users from even being able to grow their clusters to that size:\nthe time it takes kube-proxy to program new iptables rules when\nServices and their endpoints change.</p>\n<p>With both iptables and nftables, the total size of the ruleset as a\nwhole (actual rules, plus associated data) is <strong>O(n)</strong> in the combined\nnumber of Services and their endpoints. Originally, the iptables\nbackend would rewrite every rule on every update, and with tens of\nthousands of Services, this could grow to be hundreds of thousands of\niptables rules. Starting in Kubernetes 1.26, we began improving\nkube-proxy so that it could skip updating <em>most</em> of the unchanged\nrules in each update, but the limitations of <code>iptables-restore</code> as an\nAPI meant that it was still always necessary to send an update that's\n<strong>O(n)</strong> in the number of Services (though with a noticeably smaller\nconstant than it used to be). Even with those optimizations, it can\nstill be necessary to make use of kube-proxy's <code>minSyncPeriod</code> config\noption to ensure that it doesn't spend every waking second trying to\npush iptables updates.</p>\n<p>The nftables APIs allow for doing much more incremental updates, and\nwhen kube-proxy in nftables mode does an update, the size of the\nupdate is only <strong>O(n)</strong> in the number of Services and endpoints that\nhave changed since the last sync, regardless of the total number of\nServices and endpoints. The fact that the nftables API allows each\nnftables-using component to have its own private table also means that\nthere is no global lock contention between components like with\niptables. As a result, kube-proxy's nftables updates can be done much\nmore efficiently than with iptables.</p>\n<p>(Unfortunately I don't have cool graphs for this part.)</p>\n<h2 id=\"why-not-nftables\">Why <em>not</em> nftables?</h2>\n<p>All that said, there are a few reasons why you might not want to jump\nright into using the nftables backend for now.</p>\n<p>First, the code is still fairly new. While it has plenty of unit\ntests, performs correctly in our CI system, and has now been used in\nthe real world by multiple users, it has not seen anything close to as\nmuch real-world usage as the iptables backend has, so we can't promise\nthat it is as stable and bug-free.</p>\n<p>Second, the nftables mode will not work on older Linux distributions;\ncurrently it requires a 5.13 or newer kernel. Additionally, because of\nbugs in early versions of the <code>nft</code> command line tool, you should not\nrun kube-proxy in nftables mode on nodes that have an old (earlier\nthan 1.0.0) version of <code>nft</code> in the host filesystem (or else\nkube-proxy's use of nftables may interfere with other uses of nftables\non the system).</p>\n<p>Third, you may have other networking components in your cluster, such\nas the pod network or NetworkPolicy implementation, that do not yet\nsupport kube-proxy in nftables mode. You should consult the\ndocumentation (or forums, bug tracker, etc.) for any such components\nto see if they have problems with nftables mode. (In many cases they\nwill not; as long as they don't try to directly interact with or\noverride kube-proxy's iptables rules, they shouldn't care whether\nkube-proxy is using iptables or nftables.) Additionally, observability\nand monitoring tools that have not been updated may report less data\nfor kube-proxy in nftables mode than they do for kube-proxy in\niptables mode.</p>\n<p>Finally, kube-proxy in nftables mode is intentionally not 100%\ncompatible with kube-proxy in iptables mode. There are a few old\nkube-proxy features whose default behaviors are less secure, less\nperformant, or less intuitive than we'd like, but where we felt that\nchanging the default would be a compatibility break. Since the\nnftables mode is opt-in, this gave us a chance to fix those bad\ndefaults without breaking users who weren't expecting changes. (In\nparticular, with nftables mode, NodePort Services are now only\nreachable on their nodes' default IPs, as opposed to being reachable\non all IPs, including <code>127.0.0.1</code>, with iptables mode.) The\n<a href=\"https://kubernetes.io/docs/reference/networking/virtual-ips/#migrating-from-iptables-mode-to-nftables\">kube-proxy documentation</a> has more information about this, including\ninformation about metrics you can look at to determine if you are\nrelying on any of the changed functionality, and what configuration\noptions are available to get more backward-compatible behavior.</p>\n<h2 id=\"trying-out-nftables-mode\">Trying out nftables mode</h2>\n<p>Ready to try it out? In Kubernetes 1.31 and later, you just need to\npass <code>--proxy-mode nftables</code> to kube-proxy (or set <code>mode: nftables</code> in\nyour kube-proxy config file).</p>\n<p>If you are using kubeadm to set up your cluster, the kubeadm\ndocumentation explains <a href=\"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/control-plane-flags/#customizing-kube-proxy\">how to pass a <code>KubeProxyConfiguration</code> to\n<code>kubeadm init</code></a>. You can also <a href=\"https://kind.sigs.k8s.io/docs/user/configuration/#kube-proxy-mode\">deploy nftables-based clusters with\n<code>kind</code></a>.</p>\n<p>You can also convert existing clusters from iptables (or ipvs) mode to\nnftables by updating the kube-proxy configuration and restarting the\nkube-proxy pods. (You do not need to reboot the nodes: when restarting\nin nftables mode, kube-proxy will delete any existing iptables or ipvs\nrules, and likewise, if you later revert back to iptables or ipvs\nmode, it will delete any existing nftables rules.)</p>\n<h2 id=\"future-plans\">Future plans</h2>\n<p>As mentioned above, while nftables is now the <em>best</em> kube-proxy mode,\nit is not the <em>default</em>, and we do not yet have a plan for changing\nthat. We will continue to support the iptables mode for a long time.</p>\n<p>The future of the IPVS mode of kube-proxy is less certain: its main\nadvantage over iptables was that it was faster, but certain aspects of\nthe IPVS architecture and APIs were awkward for kube-proxy's purposes\n(for example, the fact that the <code>kube-ipvs0</code> device needs to have\n<em>every</em> Service IP address assigned to it), and some parts of\nKubernetes Service proxying semantics were difficult to implement\nusing IPVS (particularly the fact that some Services had to have\ndifferent endpoints depending on whether you connected to them from a\nlocal or remote client). And now, the nftables mode has the same\nperformance as IPVS mode (actually, slightly better), without any of\nthe downsides:</p>\n<figure>\n<img alt=\"kube-proxy ipvs-vs-nftables first packet latency, at various percentiles, in clusters of various sizes\" src=\"https://kubernetes.io/blog/2025/02/28/nftables-kube-proxy/ipvs-vs-nftables.svg\" />\n</figure>\n<p>(In theory the IPVS mode also has the advantage of being able to use\nvarious other IPVS functionality, like alternative &quot;schedulers&quot; for\nbalancing endpoints. In practice, this ended up not being very useful,\nbecause kube-proxy runs independently on every node, and the IPVS\nschedulers on each node had no way of sharing their state with the\nproxies on other nodes, thus thwarting the effort to balance traffic\nmore cleverly.)</p>\n<p>While the Kubernetes project does not have an immediate plan to drop\nthe IPVS backend, it is probably doomed in the long run, and people\nwho are currently using IPVS mode should try out the nftables mode\ninstead (and file bugs if you think there is missing functionality in\nnftables mode that you can't work around).</p>\n<h2 id=\"learn-more\">Learn more</h2>\n<ul>\n<li>\n<p>&quot;<a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/3866-nftables-proxy/README.md\">KEP-3866: Add an nftables-based kube-proxy backend</a>&quot; has the\nhistory of the new feature.</p>\n</li>\n<li>\n<p>&quot;<a href=\"https://youtu.be/yOGHb2HjslY?si=6O4PVJu7fGpReo1U\">How the Tables Have Turned: Kubernetes Says Goodbye to IPTables</a>&quot;,\nfrom KubeCon/CloudNativeCon North America 2024, talks about porting\nkube-proxy and Calico from iptables to nftables.</p>\n</li>\n<li>\n<p>&quot;<a href=\"https://youtu.be/uYo2O3jbJLk?si=py2AXzMJZ4PuhxNg\">From Observability to Performance</a>&quot;, from KubeCon/CloudNativeCon\nNorth America 2024. (This is where the kube-proxy latency data came\nfrom; the <a href=\"https://docs.google.com/spreadsheets/d/1-ryDNc6gZocnMHEXC7mNtqknKSOv5uhXFKDx8Hu3AYA/edit\">raw data for the charts</a> is also available.)</p>\n</li>\n</ul>",
      "timestamp": 1741428556.9202113,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "The Cloud Controller Manager Chicken and Egg Problem",
      "link": "https://kubernetes.io/blog/2025/02/14/cloud-controller-manager-chicken-egg-problem/",
      "published": "Fri, 14 Feb 2025 00:00:00 +0000",
      "summary": "<p>Kubernetes 1.31\n<a href=\"https://kubernetes.io/blog/2024/05/20/completing-cloud-provider-migration/\">completed the largest migration in Kubernetes history</a>, removing the in-tree\ncloud provider. While the component migration is now done, this leaves some additional\ncomplexity for users and installer projects (for example, kOps or Cluster API) . We will go\nover those additional steps and failure points and make recommendations for cluster owners.\nThis migration was complex and some logic had to be extracted from the core components,\nbuilding four new subsystems.</p>\n<ol>\n<li><strong>Cloud controller manager</strong> (<a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/sig-cloud-provider/2392-cloud-controller-manager/README.md\">KEP-2392</a>)</li>\n<li><strong>API server network proxy</strong> (<a href=\"https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1281-network-proxy\">KEP-1281</a>)</li>\n<li><strong>kubelet credential provider plugins</strong> (<a href=\"https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2133-kubelet-credential-providers\">KEP-2133</a>)</li>\n<li><strong>Storage migration to use <a href=\"https://github.com/container-storage-interface/spec?tab=readme-ov-file#container-storage-interface-csi-specification-\">CSI</a></strong> (<a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/625-csi-migration/README.md\">KEP-625</a>)</li>\n</ol>\n<p>The <a href=\"https://kubernetes.io/docs/concepts/architecture/cloud-controller/\">cloud controller manager is part of the control plane</a>. It is a critical component\nthat replaces some functionality that existed previously in the kube-controller-manager and the\nkubelet.</p>\n<figure>\n<img alt=\"Components of Kubernetes\" src=\"https://kubernetes.io/images/docs/components-of-kubernetes.svg\" /> <figcaption>\n<p>Components of Kubernetes</p>\n</figcaption>\n</figure>\n<p>One of the most critical functionalities of the cloud controller manager is the node controller,\nwhich is responsible for the initialization of the nodes.</p>\n<p>As you can see in the following diagram, when the <strong>kubelet</strong> starts, it registers the Node\nobject with the apiserver, Tainting the node so it can be processed first by the\ncloud-controller-manager. The initial Node is missing the cloud-provider specific information,\nlike the Node Addresses and the Labels with the cloud provider specific information like the\nNode, Region and Instance type information.</p>\n<figure class=\"diagram-medium \">\n<img alt=\"Chicken and egg problem sequence diagram\" src=\"https://kubernetes.io/blog/2025/02/14/cloud-controller-manager-chicken-egg-problem/ccm-chicken-egg-problem-sequence-diagram.svg\" /> <figcaption>\n<p>Chicken and egg problem sequence diagram</p>\n</figcaption>\n</figure>\n<p>This new initialization process adds some latency to the node readiness. Previously, the kubelet\nwas able to initialize the node at the same time it created the node. Since the logic has moved\nto the cloud-controller-manager, this can cause a <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/#chicken-and-egg\">chicken and egg problem</a>\nduring the cluster bootstrapping for those Kubernetes architectures that do not deploy the\ncontroller manager as the other components of the control plane, commonly as static pods,\nstandalone binaries or daemonsets/deployments with tolerations to the taints and using\n<code>hostNetwork</code> (more on this below)</p>\n<h2 id=\"examples-of-the-dependency-problem\">Examples of the dependency problem</h2>\n<p>As noted above, it is possible during bootstrapping for the cloud-controller-manager to be\nunschedulable and as such the cluster will not initialize properly. The following are a few\nconcrete examples of how this problem can be expressed and the root causes for why they might\noccur.</p>\n<p>These examples assume you are running your cloud-controller-manager using a Kubernetes resource\n(e.g. Deployment, DaemonSet, or similar) to control its lifecycle. Because these methods\nrely on Kubernetes to schedule the cloud-controller-manager, care must be taken to ensure it\nwill schedule properly.</p>\n<h3 id=\"example-cloud-controller-manager-not-scheduling-due-to-uninitialized-taint\">Example: Cloud controller manager not scheduling due to uninitialized taint</h3>\n<p>As <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/#running-cloud-controller-manager\">noted in the Kubernetes documentation</a>, when the kubelet is started with the command line\nflag <code>--cloud-provider=external</code>, its corresponding <code>Node</code> object will have a no schedule taint\nnamed <code>node.cloudprovider.kubernetes.io/uninitialized</code> added. Because the cloud-controller-manager\nis responsible for removing the no schedule taint, this can create a situation where a\ncloud-controller-manager that is being managed by a Kubernetes resource, such as a <code>Deployment</code>\nor <code>DaemonSet</code>, may not be able to schedule.</p>\n<p>If the cloud-controller-manager is not able to be scheduled during the initialization of the\ncontrol plane, then the resulting <code>Node</code> objects will all have the\n<code>node.cloudprovider.kubernetes.io/uninitialized</code> no schedule taint. It also means that this taint\nwill not be removed as the cloud-controller-manager is responsible for its removal. If the no\nschedule taint is not removed, then critical workloads, such as the container network interface\ncontrollers, will not be able to schedule, and the cluster will be left in an unhealthy state.</p>\n<h3 id=\"example-cloud-controller-manager-not-scheduling-due-to-not-ready-taint\">Example: Cloud controller manager not scheduling due to not-ready taint</h3>\n<p>The next example would be possible in situations where the container network interface (CNI) is\nwaiting for IP address information from the cloud-controller-manager (CCM), and the CCM has not\ntolerated the taint which would be removed by the CNI.</p>\n<p>The <a href=\"https://kubernetes.io/docs/reference/labels-annotations-taints/#node-kubernetes-io-not-ready\">Kubernetes documentation describes</a> the <code>node.kubernetes.io/not-ready</code> taint as follows:</p>\n<blockquote>\n<p>&quot;The Node controller detects whether a Node is ready by monitoring its health and adds or removes this taint accordingly.&quot;</p>\n</blockquote>\n<p>One of the conditions that can lead to a Node resource having this taint is when the container\nnetwork has not yet been initialized on that node. As the cloud-controller-manager is responsible\nfor adding the IP addresses to a Node resource, and the IP addresses are needed by the container\nnetwork controllers to properly configure the container network, it is possible in some\ncircumstances for a node to become stuck as not ready and uninitialized permanently.</p>\n<p>This situation occurs for a similar reason as the first example, although in this case, the\n<code>node.kubernetes.io/not-ready</code> taint is used with the no execute effect and thus will cause the\ncloud-controller-manager not to run on the node with the taint. If the cloud-controller-manager is\nnot able to execute, then it will not initialize the node. It will cascade into the container\nnetwork controllers not being able to run properly, and the node will end up carrying both the\n<code>node.cloudprovider.kubernetes.io/uninitialized</code> and <code>node.kubernetes.io/not-ready</code> taints,\nleaving the cluster in an unhealthy state.</p>\n<h2 id=\"our-recommendations\">Our Recommendations</h2>\n<p>There is no one “correct way” to run a cloud-controller-manager. The details will depend on the\nspecific needs of the cluster administrators and users. When planning your clusters and the\nlifecycle of the cloud-controller-managers please consider the following guidance:</p>\n<p>For cloud-controller-managers running in the same cluster, they are managing.</p>\n<ol>\n<li>Use host network mode, rather than the pod network: in most cases, a cloud controller manager\nwill need to communicate with an API service endpoint associated with the infrastructure.\nSetting “hostNetwork” to true will ensure that the cloud controller is using the host\nnetworking instead of the container network and, as such, will have the same network access as\nthe host operating system. It will also remove the dependency on the networking plugin. This\nwill ensure that the cloud controller has access to the infrastructure endpoint (always check\nyour networking configuration against your infrastructure provider’s instructions).</li>\n<li>Use a scalable resource type. <code>Deployments</code> and <code>DaemonSets</code> are useful for controlling the\nlifecycle of a cloud controller. They allow easy access to running multiple copies for redundancy\nas well as using the Kubernetes scheduling to ensure proper placement in the cluster. When using\nthese primitives to control the lifecycle of your cloud controllers and running multiple\nreplicas, you must remember to enable leader election, or else your controllers will collide\nwith each other which could lead to nodes not being initialized in the cluster.</li>\n<li>Target the controller manager containers to the control plane. There might exist other\ncontrollers which need to run outside the control plane (for example, Azure’s node manager\ncontroller). Still, the controller managers themselves should be deployed to the control plane.\nUse a node selector or affinity stanza to direct the scheduling of cloud controllers to the\ncontrol plane to ensure that they are running in a protected space. Cloud controllers are vital\nto adding and removing nodes to a cluster as they form a link between Kubernetes and the\nphysical infrastructure. Running them on the control plane will help to ensure that they run\nwith a similar priority as other core cluster controllers and that they have some separation\nfrom non-privileged user workloads.\n<ol>\n<li>It is worth noting that an anti-affinity stanza to prevent cloud controllers from running\non the same host is also very useful to ensure that a single node failure will not degrade\nthe cloud controller performance.</li>\n</ol>\n</li>\n<li>Ensure that the tolerations allow operation. Use tolerations on the manifest for the cloud\ncontroller container to ensure that it will schedule to the correct nodes and that it can run\nin situations where a node is initializing. This means that cloud controllers should tolerate\nthe <code>node.cloudprovider.kubernetes.io/uninitialized</code> taint, and it should also tolerate any\ntaints associated with the control plane (for example, <code>node-role.kubernetes.io/control-plane</code>\nor <code>node-role.kubernetes.io/master</code>). It can also be useful to tolerate the\n<code>node.kubernetes.io/not-ready</code> taint to ensure that the cloud controller can run even when the\nnode is not yet available for health monitoring.</li>\n</ol>\n<p>For cloud-controller-managers that will not be running on the cluster they manage (for example,\nin a hosted control plane on a separate cluster), then the rules are much more constrained by the\ndependencies of the environment of the cluster running the cloud-controller-manager. The advice\nfor running on a self-managed cluster may not be appropriate as the types of conflicts and network\nconstraints will be different. Please consult the architecture and requirements of your topology\nfor these scenarios.</p>\n<h3 id=\"example\">Example</h3>\n<p>This is an example of a Kubernetes Deployment highlighting the guidance shown above. It is\nimportant to note that this is for demonstration purposes only, for production uses please\nconsult your cloud provider’s documentation.</p>\n<pre tabindex=\"0\"><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\nlabels:\napp.kubernetes.io/name: cloud-controller-manager\nname: cloud-controller-manager\nnamespace: kube-system\nspec:\nreplicas: 2\nselector:\nmatchLabels:\napp.kubernetes.io/name: cloud-controller-manager\nstrategy:\ntype: Recreate\ntemplate:\nmetadata:\nlabels:\napp.kubernetes.io/name: cloud-controller-manager\nannotations:\nkubernetes.io/description: Cloud controller manager for my infrastructure\nspec:\ncontainers: # the container details will depend on your specific cloud controller manager\n- name: cloud-controller-manager\ncommand:\n- /bin/my-infrastructure-cloud-controller-manager\n- --leader-elect=true\n- -v=1\nimage: registry/my-infrastructure-cloud-controller-manager@latest\nresources:\nrequests:\ncpu: 200m\nmemory: 50Mi\nhostNetwork: true # these Pods are part of the control plane\nnodeSelector:\nnode-role.kubernetes.io/control-plane: \"\"\naffinity:\npodAntiAffinity:\nrequiredDuringSchedulingIgnoredDuringExecution:\n- topologyKey: \"kubernetes.io/hostname\"\nlabelSelector:\nmatchLabels:\napp.kubernetes.io/name: cloud-controller-manager\ntolerations:\n- effect: NoSchedule\nkey: node-role.kubernetes.io/master\noperator: Exists\n- effect: NoExecute\nkey: node.kubernetes.io/unreachable\noperator: Exists\ntolerationSeconds: 120\n- effect: NoExecute\nkey: node.kubernetes.io/not-ready\noperator: Exists\ntolerationSeconds: 120\n- effect: NoSchedule\nkey: node.cloudprovider.kubernetes.io/uninitialized\noperator: Exists\n- effect: NoSchedule\nkey: node.kubernetes.io/not-ready\noperator: Exists\n</code></pre><p>When deciding how to deploy your cloud controller manager it is worth noting that\ncluster-proportional, or resource-based, pod autoscaling is not recommended. Running multiple\nreplicas of a cloud controller manager is good practice for ensuring high-availability and\nredundancy, but does not contribute to better performance. In general, only a single instance\nof a cloud controller manager will be reconciling a cluster at any given time.</p>",
      "timestamp": 1741428556.9202151,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Spotlight on SIG Architecture: Enhancements",
      "link": "https://kubernetes.io/blog/2025/01/21/sig-architecture-enhancements/",
      "published": "Tue, 21 Jan 2025 00:00:00 +0000",
      "summary": "<p><em>This is the fourth interview of a SIG Architecture Spotlight series that will cover the different\nsubprojects, and we will be covering <a href=\"https://github.com/kubernetes/community/blob/master/sig-architecture/README.md#enhancements\">SIG Architecture:\nEnhancements</a>.</em></p>\n<p>In this SIG Architecture spotlight we talked with <a href=\"https://github.com/kikisdeliveryservice\">Kirsten\nGarrison</a>, lead of the Enhancements subproject.</p>\n<h2 id=\"the-enhancements-subproject\">The Enhancements subproject</h2>\n<p><strong>Frederico (FSM): Hi Kirsten, very happy to have the opportunity to talk about the Enhancements\nsubproject. Let's start with some quick information about yourself and your role.</strong></p>\n<p><strong>Kirsten Garrison (KG)</strong>: I’m a lead of the Enhancements subproject of SIG-Architecture and\ncurrently work at Google. I first got involved by contributing to the service-catalog project with\nthe help of <a href=\"https://github.com/carolynvs\">Carolyn Van Slyck</a>. With time, <a href=\"https://github.com/kubernetes/sig-release/blob/master/releases/release-1.17/release_team.md\">I joined the Release\nteam</a>,\neventually becoming the Enhancements Lead and a Release Lead shadow. While on the release team, I\nworked on some ideas to make the process better for the SIGs and Enhancements team (the opt-in\nprocess) based on my team’s experiences. Eventually, I started attending Subproject meetings and\ncontributing to the Subproject’s work.</p>\n<p><strong>FSM: You mentioned the Enhancements subproject: how would you describe its main goals and areas of\nintervention?</strong></p>\n<p><strong>KG</strong>: The <a href=\"https://github.com/kubernetes/community/blob/master/sig-architecture/README.md#enhancements\">Enhancements\nSubproject</a>\nprimarily concerns itself with the <a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/sig-architecture/0000-kep-process/README.md\">Kubernetes Enhancement\nProposal</a>\n(<em>KEP</em> for short)—the &quot;design&quot; documents required for all features and significant changes\nto the Kubernetes project.</p>\n<h2 id=\"the-kep-and-its-impact\">The KEP and its impact</h2>\n<p><strong>FSM: The improvement of the KEP process was (and is) one in which SIG Architecture was heavily\ninvolved. Could you explain the process to those that aren’t aware of it?</strong></p>\n<p><strong>KG</strong>: <a href=\"https://kubernetes.io/releases/release/#the-release-cycle\">Every release</a>, the SIGs let the\nRelease Team know which features they intend to work on to be put into the release. As mentioned\nabove, the prerequisite for these changes is a KEP - a standardized design document that all authors\nmust fill out and approve in the first weeks of the release cycle. Most features <a href=\"https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/#feature-stages\">will move\nthrough 3\nphases</a>:\nalpha, beta and finally GA so approving a feature represents a significant commitment for the SIG.</p>\n<p>The KEP serves as the full source of truth of a feature. The <a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/NNNN-kep-template/README.md\">KEP\ntemplate</a>\nhas different requirements based on what stage a feature is in, but it generally requires a detailed\ndiscussion of the design and the impact as well as providing artifacts of stability and\nperformance. The KEP takes quite a bit of iterative work between authors, SIG reviewers, api review\nteam and the Production Readiness Review team<sup id=\"fnref:1\"><a class=\"footnote-ref\" href=\"https://kubernetes.io/feed.xml#fn:1\">1</a></sup> before it is approved. Each set of reviewers is\nlooking to make sure that the proposal meets their standards in order to have a stable and\nperformant Kubernetes release. Only after all approvals are secured, can an author go forth and\nmerge their feature in the Kubernetes code base.</p>\n<p><strong>FSM: I see, quite a bit of additional structure was added. Looking back, what were the most\nsignificant improvements of that approach?</strong></p>\n<p><strong>KG</strong>: In general, I think that the improvements with the most impact had to do with focusing on\nthe core intent of the KEP. KEPs exist not just to memorialize designs, but provide a structured way\nto discuss and come to an agreement about different facets of the change. At the core of the KEP\nprocess is communication and consideration.</p>\n<p>To that end, some of the significant changes revolve around a more detailed and accessible KEP\ntemplate. A significant amount of work was put in over time to get the\n<a href=\"https://github.com/kubernetes/enhancements\">k/enhancements</a> repo into its current form -- a\ndirectory structure organized by SIG with the contours of the modern KEP template (with\nProposal/Motivation/Design Details subsections). We might take that basic structure for granted\ntoday, but it really represents the work of many people trying to get the foundation of this process\nin place over time.</p>\n<p>As Kubernetes matures, we’ve needed to think about more than just the end goal of getting a single\nfeature merged. We need to think about things like: stability, performance, setting and meeting user\nexpectations. And as we’ve thought about those things the template has grown more detailed. The\naddition of the Production Readiness Review was major as well as the enhanced testing requirements\n(varying at different stages of a KEP’s lifecycle).</p>\n<h2 id=\"current-areas-of-focus\">Current areas of focus</h2>\n<p><strong>FSM: Speaking of maturing, we’ve <a href=\"https://kubernetes.io/blog/2024/08/13/kubernetes-v1-31-release/\">recently released Kubernetes\nv1.31</a>, and work on v1.32 <a href=\"https://github.com/fsmunoz/sig-release/tree/release-1.32/releases/release-1.32\">has\nstarted</a>. Are there\nany areas that the Enhancements sub-project is currently addressing that might change the way things\nare done?</strong></p>\n<p><strong>KG</strong>: We’re currently working on two things:</p>\n<ol>\n<li><em>Creating a Process KEP template.</em> Sometimes people want to harness the KEP process for\nsignificant changes that are more process oriented rather than feature oriented. We want to\nsupport this because memorializing changes is important and giving people a better tool to do so\nwill only encourage more discussion and transparency.</li>\n<li><em>KEP versioning.</em> While our template changes aim to be as non-disruptive as possible, we\nbelieve that it will be easier to track and communicate those changes to the community better with\na versioned KEP template and the policies that go alongside such versioning.</li>\n</ol>\n<p>Both features will take some time to get right and fully roll out (just like a KEP feature) but we\nbelieve that they will both provide improvements that will benefit the community at large.</p>\n<p><strong>FSM: You mentioned improvements: I remember when project boards for Enhancement tracking were\nintroduced in recent releases, to great effect and unanimous applause from release team members. Was\nthis a particular area of focus for the subproject?</strong></p>\n<p><strong>KG</strong>: The Subproject provided support to the Release Team’s Enhancement team in the migration away\nfrom using the spreadsheet to a project board. The collection and tracking of enhancements has\nalways been a logistical challenge. During my time on the Release Team, I helped with the transition\nto an opt-in system of enhancements, whereby the SIG leads &quot;opt-in&quot; KEPs for release tracking. This\nhelped to enhance communication between authors and SIGs before any significant work was undertaken\non a KEP and removed toil from the Enhancements team. This change used the existing tools to avoid\nintroducing too many changes at once to the community. Later, the Release Team approached the\nSubproject with an idea of leveraging GitHub Project Boards to further improve the collection\nprocess. This was to be a move away from the use of complicated spreadsheets to using repo-native\nlabels on <a href=\"https://github.com/kubernetes/enhancements\">k/enhancement</a> issues and project boards.</p>\n<p><strong>FSM: That surely adds an impact on simplifying the workflow...</strong></p>\n<p><strong>KG</strong>: Removing sources of friction and promoting clear communication is very important to the\nEnhancements Subproject. At the same time, it’s important to give careful consideration to\ndecisions that impact the community as a whole. We want to make sure that changes are balanced to\ngive an upside and while not causing any regressions and pain in the rollout. We supported the\nRelease Team in ideation as well as through the actual migration to the project boards. It was a\ngreat success and exciting to see the team make high impact changes that helped everyone involved in\nthe KEP process!</p>\n<h2 id=\"getting-involved\">Getting involved</h2>\n<p><strong>FSM: For those reading that might be curious and interested in helping, how would you describe the\nrequired skills for participating in the sub-project?</strong></p>\n<p><strong>KG</strong>: Familiarity with KEPs either via experience or taking time to look through the\nkubernetes/enhancements repo is helpful. All are welcome to participate if interested - we can take\nit from there.</p>\n<p><strong>FSM: Excellent! Many thanks for your time and insight -- any final comments you would like to\nshare with our readers?</strong></p>\n<p><strong>KG</strong>: The Enhancements process is one of the most important parts of Kubernetes and requires\nenormous amounts of coordination and collaboration of people and teams across the project to make it\nsuccessful. I’m thankful and inspired by everyone’s continued hard work and dedication to making the\nproject great. This is truly a wonderful community.</p>\n<div class=\"footnotes\">\n<hr />\n<ol>\n<li id=\"fn:1\">\n<p>For more information, check the <a href=\"https://kubernetes.io/blog/2023/11/02/sig-architecture-production-readiness-spotlight-2023/\">Production Readiness Review spotlight\ninterview</a>\nin this series.&#160;<a class=\"footnote-backref\" href=\"https://kubernetes.io/feed.xml#fnref:1\">&#x21a9;&#xfe0e;</a></p>\n</li>\n</ol>\n</div>",
      "timestamp": 1741428556.92022,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Kubernetes 1.32: Moving Volume Group Snapshots to Beta",
      "link": "https://kubernetes.io/blog/2024/12/18/kubernetes-1-32-volume-group-snapshot-beta/",
      "published": "Wed, 18 Dec 2024 00:00:00 +0000",
      "summary": "<p>Volume group snapshots were <a href=\"https://kubernetes.io/blog/2023/05/08/kubernetes-1-27-volume-group-snapshot-alpha/\">introduced</a>\nas an Alpha feature with the Kubernetes 1.27 release.\nThe recent release of Kubernetes v1.32 moved that support to <strong>beta</strong>.\nThe support for volume group snapshots relies on a set of\n<a href=\"https://kubernetes-csi.github.io/docs/group-snapshot-restore-feature.html#volume-group-snapshot-apis\">extension APIs for group snapshots</a>.\nThese APIs allow users to take crash consistent snapshots for a set of volumes.\nBehind the scenes, Kubernetes uses a label selector to group multiple PersistentVolumeClaims\nfor snapshotting.\nA key aim is to allow you restore that set of snapshots to new volumes and\nrecover your workload based on a crash consistent recovery point.</p>\n<p>This new feature is only supported for <a href=\"https://kubernetes-csi.github.io/docs/\">CSI</a> volume drivers.</p>\n<h2 id=\"an-overview-of-volume-group-snapshots\">An overview of volume group snapshots</h2>\n<p>Some storage systems provide the ability to create a crash consistent snapshot of\nmultiple volumes. A group snapshot represents <em>copies</em> made from multiple volumes, that\nare taken at the same point-in-time. A group snapshot can be used either to rehydrate\nnew volumes (pre-populated with the snapshot data) or to restore existing volumes to\na previous state (represented by the snapshots).</p>\n<h2 id=\"why-add-volume-group-snapshots-to-kubernetes\">Why add volume group snapshots to Kubernetes?</h2>\n<p>The Kubernetes volume plugin system already provides a powerful abstraction that\nautomates the provisioning, attaching, mounting, resizing, and snapshotting of block\nand file storage.</p>\n<p>Underpinning all these features is the Kubernetes goal of workload portability:\nKubernetes aims to create an abstraction layer between distributed applications and\nunderlying clusters so that applications can be agnostic to the specifics of the\ncluster they run on and application deployment requires no cluster specific knowledge.</p>\n<p>There was already a <a href=\"https://kubernetes.io/docs/concepts/storage/volume-snapshots/\">VolumeSnapshot</a> API\nthat provides the ability to take a snapshot of a persistent volume to protect against\ndata loss or data corruption. However, there are other snapshotting functionalities\nnot covered by the VolumeSnapshot API.</p>\n<p>Some storage systems support consistent group snapshots that allow a snapshot to be\ntaken from multiple volumes at the same point-in-time to achieve write order consistency.\nThis can be useful for applications that contain multiple volumes. For example,\nan application may have data stored in one volume and logs stored in another volume.\nIf snapshots for the data volume and the logs volume are taken at different times,\nthe application will not be consistent and will not function properly if it is restored\nfrom those snapshots when a disaster strikes.</p>\n<p>It is true that you can quiesce the application first, take an individual snapshot from\neach volume that is part of the application one after the other, and then unquiesce the\napplication after all the individual snapshots are taken. This way, you would get\napplication consistent snapshots.</p>\n<p>However, sometimes the application quiesce can be so time consuming that you want to do it less frequently,\nor it may not be possible to quiesce an application at all.\nFor example, a user may want to run weekly backups with application quiesce\nand nightly backups without application quiesce but with consistent group support which\nprovides crash consistency across all volumes in the group.</p>\n<h2 id=\"kubernetes-apis-for-volume-group-snapshots\">Kubernetes APIs for volume group snapshots</h2>\n<p>Kubernetes' support for <em>volume group snapshots</em> relies on three API kinds that\nare used\nfor managing snapshots:</p>\n<dl>\n<dt>VolumeGroupSnapshot</dt>\n<dd>Created by a Kubernetes user (or perhaps by your own automation) to request\ncreation of a volume group snapshot for multiple persistent volume claims.\nIt contains information about the volume group snapshot operation such as the\ntimestamp when the volume group snapshot was taken and whether it is ready to use.\nThe creation and deletion of this object represents a desire to create or delete a\ncluster resource (a group snapshot).</dd>\n<dt>VolumeGroupSnapshotContent</dt>\n<dd>Created by the snapshot controller for a dynamically created VolumeGroupSnapshot.\nIt contains information about the volume group snapshot including the volume group\nsnapshot ID.\nThis object represents a provisioned resource on the cluster (a group snapshot).\nThe VolumeGroupSnapshotContent object binds to the VolumeGroupSnapshot for which it\nwas created with a one-to-one mapping.</dd>\n<dt>VolumeGroupSnapshotClass</dt>\n<dd>Created by cluster administrators to describe how volume group snapshots should be\ncreated, including the driver information, the deletion policy, etc.</dd>\n</dl>\n<p>These three API kinds are defined as\n<a href=\"https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/\">CustomResourceDefinitions</a>\n(CRDs).\nThese CRDs must be installed in a Kubernetes cluster for a CSI Driver to support\nvolume group snapshots.</p>\n<h2 id=\"what-components-are-needed-to-support-volume-group-snapshots\">What components are needed to support volume group snapshots</h2>\n<p>Volume group snapshots are implemented in the\n<a href=\"https://github.com/kubernetes-csi/external-snapshotter\">external-snapshotter</a> repository.\nImplementing volume group snapshots meant adding or changing several components:</p>\n<ul>\n<li>Added new CustomResourceDefinitions for VolumeGroupSnapshot and two supporting APIs.</li>\n<li>Volume group snapshot controller logic is added to the common snapshot controller.</li>\n<li>Adding logic to make CSI calls into the snapshotter sidecar controller.</li>\n</ul>\n<p>The volume snapshot controller and CRDs are deployed once per\ncluster, while the sidecar is bundled with each CSI driver.</p>\n<p>Therefore, it makes sense to deploy the volume snapshot controller and CRDs as a cluster addon.</p>\n<p>The Kubernetes project recommends that Kubernetes distributors\nbundle and deploy the volume snapshot controller and CRDs as part\nof their Kubernetes cluster management process (independent of any CSI Driver).</p>\n<h2 id=\"what-s-new-in-beta\">What's new in Beta?</h2>\n<ul>\n<li>\n<p>The VolumeGroupSnapshot feature in CSI spec moved to GA in the <a href=\"https://github.com/container-storage-interface/spec/releases/tag/v1.11.0\">v1.11.0 release</a>.</p>\n</li>\n<li>\n<p>The snapshot validation webhook was deprecated in external-snapshotter v8.0.0 and it is now removed.\nMost of the validation webhook logic was added as validation rules into the CRDs.\nMinimum required Kubernetes version is 1.25 for these validation rules.\nOne thing in the validation webhook not moved to CRDs is the prevention of creating\nmultiple default volume snapshot classes and multiple default volume group snapshot classes\nfor the same CSI driver.\nWith the removal of the validation webhook, an error will still be raised when dynamically\nprovisioning a VolumeSnapshot or VolumeGroupSnapshot when multiple default volume snapshot\nclasses or multiple default volume group snapshot classes for the same CSI driver exist.</p>\n</li>\n<li>\n<p>The <code>enable-volumegroup-snapshot</code> flag in the snapshot-controller and the CSI snapshotter\nsidecar has been replaced by a feature gate.\nSince VolumeGroupSnapshot is a new API, the feature moves to Beta but the feature gate is\ndisabled by default.\nTo use this feature, enable the feature gate by adding the flag <code>--feature-gates=CSIVolumeGroupSnapshot=true</code>\nwhen starting the snapshot-controller and the CSI snapshotter sidecar.</p>\n</li>\n<li>\n<p>The logic to dynamically create the VolumeGroupSnapshot and its corresponding individual\nVolumeSnapshot and VolumeSnapshotContent objects are moved from the CSI snapshotter to the common\nsnapshot-controller.\nNew RBAC rules are added to the common snapshot-controller and some RBAC rules are removed from\nthe CSI snapshotter sidecar accordingly.</p>\n</li>\n</ul>\n<h2 id=\"how-do-i-use-kubernetes-volume-group-snapshots\">How do I use Kubernetes volume group snapshots</h2>\n<h3 id=\"creating-a-new-group-snapshot-with-kubernetes\">Creating a new group snapshot with Kubernetes</h3>\n<p>Once a VolumeGroupSnapshotClass object is defined and you have volumes you want to\nsnapshot together, you may request a new group snapshot by creating a VolumeGroupSnapshot\nobject.</p>\n<p>The source of the group snapshot specifies whether the underlying group snapshot\nshould be dynamically created or if a pre-existing VolumeGroupSnapshotContent\nshould be used.</p>\n<p>A pre-existing VolumeGroupSnapshotContent is created by a cluster administrator.\nIt contains the details of the real volume group snapshot on the storage system which\nis available for use by cluster users.</p>\n<p>One of the following members in the source of the group snapshot must be set.</p>\n<ul>\n<li><code>selector</code> - a label query over PersistentVolumeClaims that are to be grouped\ntogether for snapshotting. This selector will be used to match the label\nadded to a PVC.</li>\n<li><code>volumeGroupSnapshotContentName</code> - specifies the name of a pre-existing\nVolumeGroupSnapshotContent object representing an existing volume group snapshot.</li>\n</ul>\n<h4 id=\"dynamically-provision-a-group-snapshot\">Dynamically provision a group snapshot</h4>\n<p>In the following example, there are two PVCs.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-console\"><span style=\"display: flex;\"><span><span style=\"color: #888;\">NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS VOLUMEATTRIBUTESCLASS AGE\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">pvc-0 Bound pvc-6e1f7d34-a5c5-4548-b104-01e72c72b9f2 100Mi RWO csi-hostpath-sc &lt;unset&gt; 2m15s\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">pvc-1 Bound pvc-abc640b3-2cc1-4c56-ad0c-4f0f0e636efa 100Mi RWO csi-hostpath-sc &lt;unset&gt; 2m7s\n</span></span></span></code></pre></div><p>Label the PVCs.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-console\"><span style=\"display: flex;\"><span><span style=\"color: #000080; font-weight: bold;\">%</span> kubectl label pvc pvc-0 <span style=\"color: #b8860b;\">group</span><span style=\"color: #666;\">=</span>myGroup\n</span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">persistentvolumeclaim/pvc-0 labeled\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\"></span><span>\n</span></span></span><span style=\"display: flex;\"><span><span></span><span style=\"color: #000080; font-weight: bold;\">%</span> kubectl label pvc pvc-1 <span style=\"color: #b8860b;\">group</span><span style=\"color: #666;\">=</span>myGroup\n</span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">persistentvolumeclaim/pvc-1 labeled\n</span></span></span></code></pre></div><p>For dynamic provisioning, a selector must be set so that the snapshot controller can find PVCs\nwith the matching labels to be snapshotted together.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-yaml\"><span style=\"display: flex;\"><span><span style=\"color: #008000; font-weight: bold;\">apiVersion</span>:<span style=\"color: #bbb;\"> </span>groupsnapshot.storage.k8s.io/v1beta1<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>VolumeGroupSnapshot<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">metadata</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>snapshot-daily-20241217<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">namespace</span>:<span style=\"color: #bbb;\"> </span>demo-namespace<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">spec</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">volumeGroupSnapshotClassName</span>:<span style=\"color: #bbb;\"> </span>csi-groupSnapclass<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">source</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">selector</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">matchLabels</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">group</span>:<span style=\"color: #bbb;\"> </span>myGroup<span style=\"color: #bbb;\">\n</span></span></span></code></pre></div><p>In the VolumeGroupSnapshot spec, a user can specify the VolumeGroupSnapshotClass which\nhas the information about which CSI driver should be used for creating the group snapshot.\nA VolumGroupSnapshotClass is required for dynamic provisioning.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-yaml\"><span style=\"display: flex;\"><span><span style=\"color: #008000; font-weight: bold;\">apiVersion</span>:<span style=\"color: #bbb;\"> </span>groupsnapshot.storage.k8s.io/v1beta1<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>VolumeGroupSnapshotClass<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">metadata</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>csi-groupSnapclass<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">annotations</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">kubernetes.io/description</span>:<span style=\"color: #bbb;\"> </span><span style=\"color: #b44;\">\"Example group snapshot class\"</span><span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">driver</span>:<span style=\"color: #bbb;\"> </span>example.csi.k8s.io<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">deletionPolicy</span>:<span style=\"color: #bbb;\"> </span>Delete<span style=\"color: #bbb;\">\n</span></span></span></code></pre></div><p>As a result of the volume group snapshot creation, a corresponding VolumeGroupSnapshotContent\nobject will be created with a volumeGroupSnapshotHandle pointing to a resource on the storage\nsystem.</p>\n<p>Two individual volume snapshots will be created as part of the volume group snapshot creation.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-console\"><span style=\"display: flex;\"><span><span style=\"color: #888;\">NAME READYTOUSE SOURCEPVC RESTORESIZE SNAPSHOTCONTENT AGE\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">snapshot-0962a745b2bf930bb385b7b50c9b08af471f1a16780726de19429dd9c94eaca0 true pvc-0 100Mi snapcontent-0962a745b2bf930bb385b7b50c9b08af471f1a16780726de19429dd9c94eaca0 16m\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">snapshot-da577d76bd2106c410616b346b2e72440f6ec7b12a75156263b989192b78caff true pvc-1 100Mi snapcontent-da577d76bd2106c410616b346b2e72440f6ec7b12a75156263b989192b78caff 16m\n</span></span></span></code></pre></div><h4 id=\"importing-an-existing-group-snapshot-with-kubernetes\">Importing an existing group snapshot with Kubernetes</h4>\n<p>To import a pre-existing volume group snapshot into Kubernetes, you must also import\nthe corresponding individual volume snapshots.</p>\n<p>Identify the individual volume snapshot handles, manually construct a\nVolumeSnapshotContent object first, then create a VolumeSnapshot object pointing to\nthe VolumeSnapshotContent object. Repeat this for every individual volume snapshot.</p>\n<p>Then manually create a VolumeGroupSnapshotContent object, specifying the\nvolumeGroupSnapshotHandle and individual volumeSnapshotHandles already existing\non the storage system.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-yaml\"><span style=\"display: flex;\"><span><span style=\"color: #008000; font-weight: bold;\">apiVersion</span>:<span style=\"color: #bbb;\"> </span>groupsnapshot.storage.k8s.io/v1beta1<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>VolumeGroupSnapshotContent<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">metadata</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>static-group-content<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">spec</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">deletionPolicy</span>:<span style=\"color: #bbb;\"> </span>Delete<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">driver</span>:<span style=\"color: #bbb;\"> </span>hostpath.csi.k8s.io<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">source</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">groupSnapshotHandles</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">volumeGroupSnapshotHandle</span>:<span style=\"color: #bbb;\"> </span>e8779136-a93e-11ef-9549-66940726f2fd<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">volumeSnapshotHandles</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span>- e8779147-a93e-11ef-9549-66940726f2fd<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span>- e8783cd0-a93e-11ef-9549-66940726f2fd<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">volumeGroupSnapshotRef</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>static-group-snapshot<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">namespace</span>:<span style=\"color: #bbb;\"> </span>demo-namespace<span style=\"color: #bbb;\">\n</span></span></span></code></pre></div><p>After that create a VolumeGroupSnapshot object pointing to the VolumeGroupSnapshotContent\nobject.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-yaml\"><span style=\"display: flex;\"><span><span style=\"color: #008000; font-weight: bold;\">apiVersion</span>:<span style=\"color: #bbb;\"> </span>groupsnapshot.storage.k8s.io/v1beta1<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>VolumeGroupSnapshot<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">metadata</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>static-group-snapshot<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">namespace</span>:<span style=\"color: #bbb;\"> </span>demo-namespace<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">spec</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">source</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">volumeGroupSnapshotContentName</span>:<span style=\"color: #bbb;\"> </span>static-group-content<span style=\"color: #bbb;\">\n</span></span></span></code></pre></div><h3 id=\"how-to-use-group-snapshot-for-restore-in-kubernetes\">How to use group snapshot for restore in Kubernetes</h3>\n<p>At restore time, the user can request a new PersistentVolumeClaim to be created from\na VolumeSnapshot object that is part of a VolumeGroupSnapshot. This will trigger\nprovisioning of a new volume that is pre-populated with data from the specified\nsnapshot. The user should repeat this until all volumes are created from all the\nsnapshots that are part of a group snapshot.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-yaml\"><span style=\"display: flex;\"><span><span style=\"color: #008000; font-weight: bold;\">apiVersion</span>:<span style=\"color: #bbb;\"> </span>v1<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>PersistentVolumeClaim<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">metadata</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>examplepvc-restored-2024-12-17<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">namespace</span>:<span style=\"color: #bbb;\"> </span>demo-namespace<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">spec</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">storageClassName</span>:<span style=\"color: #bbb;\"> </span>example-foo-nearline<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">dataSource</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">name</span>:<span style=\"color: #bbb;\"> </span>snapshot-0962a745b2bf930bb385b7b50c9b08af471f1a16780726de19429dd9c94eaca0<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>VolumeSnapshot<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">apiGroup</span>:<span style=\"color: #bbb;\"> </span>snapshot.storage.k8s.io<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">accessModes</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span>- ReadWriteOncePod<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">resources</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">requests</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">storage</span>:<span style=\"color: #bbb;\"> </span>100Mi<span style=\"color: #bbb;\"> </span><span style=\"color: #080; font-style: italic;\"># must be enough storage to fit the existing snapshot</span><span style=\"color: #bbb;\">\n</span></span></span></code></pre></div><h2 id=\"as-a-storage-vendor-how-do-i-add-support-for-group-snapshots-to-my-csi-driver\">As a storage vendor, how do I add support for group snapshots to my CSI driver?</h2>\n<p>To implement the volume group snapshot feature, a CSI driver <strong>must</strong>:</p>\n<ul>\n<li>Implement a new group controller service.</li>\n<li>Implement group controller RPCs: <code>CreateVolumeGroupSnapshot</code>, <code>DeleteVolumeGroupSnapshot</code>, and <code>GetVolumeGroupSnapshot</code>.</li>\n<li>Add group controller capability <code>CREATE_DELETE_GET_VOLUME_GROUP_SNAPSHOT</code>.</li>\n</ul>\n<p>See the <a href=\"https://github.com/container-storage-interface/spec/blob/master/spec.md\">CSI spec</a>\nand the <a href=\"https://kubernetes-csi.github.io/docs/\">Kubernetes-CSI Driver Developer Guide</a>\nfor more details.</p>\n<p>As mentioned earlier, it is strongly recommended that Kubernetes distributors\nbundle and deploy the volume snapshot controller and CRDs as part\nof their Kubernetes cluster management process (independent of any CSI Driver).</p>\n<p>As part of this recommended deployment process, the Kubernetes team provides a number of\nsidecar (helper) containers, including the\n<a href=\"https://kubernetes-csi.github.io/docs/external-snapshotter.html\">external-snapshotter sidecar container</a>\nwhich has been updated to support volume group snapshot.</p>\n<p>The external-snapshotter watches the Kubernetes API server for\nVolumeGroupSnapshotContent objects, and triggers <code>CreateVolumeGroupSnapshot</code> and\n<code>DeleteVolumeGroupSnapshot</code> operations against a CSI endpoint.</p>\n<h2 id=\"what-are-the-limitations\">What are the limitations?</h2>\n<p>The beta implementation of volume group snapshots for Kubernetes has the following limitations:</p>\n<ul>\n<li>Does not support reverting an existing PVC to an earlier state represented by\na snapshot (only supports provisioning a new volume from a snapshot).</li>\n<li>No application consistency guarantees beyond any guarantees provided by the storage system\n(e.g. crash consistency). See this <a href=\"https://github.com/kubernetes/community/blob/30d06f49fba22273f31b3c616b74cf8745c19b3d/wg-data-protection/data-protection-workflows-white-paper.md#quiesce-and-unquiesce-hooks\">doc</a>\nfor more discussions on application consistency.</li>\n</ul>\n<h2 id=\"what-s-next\">What’s next?</h2>\n<p>Depending on feedback and adoption, the Kubernetes project plans to push the volume\ngroup snapshot implementation to general availability (GA) in a future release.</p>\n<h2 id=\"how-can-i-learn-more\">How can I learn more?</h2>\n<ul>\n<li>The <a href=\"https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/3476-volume-group-snapshot\">design spec</a>\nfor the volume group snapshot feature.</li>\n<li>The <a href=\"https://github.com/kubernetes-csi/external-snapshotter\">code repository</a> for volume group\nsnapshot APIs and controller.</li>\n<li>CSI <a href=\"https://kubernetes-csi.github.io/docs/\">documentation</a> on the group snapshot feature.</li>\n</ul>\n<h2 id=\"how-do-i-get-involved\">How do I get involved?</h2>\n<p>This project, like all of Kubernetes, is the result of hard work by many contributors\nfrom diverse backgrounds working together. On behalf of SIG Storage, I would like to\noffer a huge thank you to the contributors who stepped up these last few quarters\nto help the project reach beta:</p>\n<ul>\n<li>Ben Swartzlander (<a href=\"https://github.com/bswartz\">bswartz</a>)</li>\n<li>Cici Huang (<a href=\"https://github.com/cici37\">cici37</a>)</li>\n<li>Hemant Kumar (<a href=\"https://github.com/gnufied\">gnufied</a>)</li>\n<li>James Defelice (<a href=\"https://github.com/jdef\">jdef</a>)</li>\n<li>Jan Šafránek (<a href=\"https://github.com/jsafrane\">jsafrane</a>)</li>\n<li>Madhu Rajanna (<a href=\"https://github.com/Madhu-1\">Madhu-1</a>)</li>\n<li>Manish M Yathnalli (<a href=\"https://github.com/manishym\">manishym</a>)</li>\n<li>Michelle Au (<a href=\"https://github.com/msau42\">msau42</a>)</li>\n<li>Niels de Vos (<a href=\"https://github.com/nixpanic\">nixpanic</a>)</li>\n<li>Leonardo Cecchi (<a href=\"https://github.com/leonardoce\">leonardoce</a>)</li>\n<li>Rakshith R (<a href=\"https://github.com/Rakshith-R\">Rakshith-R</a>)</li>\n<li>Raunak Shah (<a href=\"https://github.com/RaunakShah\">RaunakShah</a>)</li>\n<li>Saad Ali (<a href=\"https://github.com/saad-ali\">saad-ali</a>)</li>\n<li>Xing Yang (<a href=\"https://github.com/xing-yang\">xing-yang</a>)</li>\n<li>Yati Padia (<a href=\"https://github.com/yati1998\">yati1998</a>)</li>\n</ul>\n<p>For those interested in getting involved with the design and development of CSI or\nany part of the Kubernetes Storage system, join the\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-storage\">Kubernetes Storage Special Interest Group</a> (SIG).\nWe always welcome new contributors.</p>\n<p>We also hold regular <a href=\"https://github.com/kubernetes/community/tree/master/wg-data-protection\">Data Protection Working Group meetings</a>.\nNew attendees are welcome to join our discussions.</p>",
      "timestamp": 1741428556.9202235,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Enhancing Kubernetes API Server Efficiency with API Streaming",
      "link": "https://kubernetes.io/blog/2024/12/17/kube-apiserver-api-streaming/",
      "published": "Tue, 17 Dec 2024 00:00:00 +0000",
      "summary": "<p>Managing Kubernetes clusters efficiently is critical, especially as their size is growing.\nA significant challenge with large clusters is the memory overhead caused by <strong>list</strong> requests.</p>\n<p>In the existing implementation, the kube-apiserver processes <strong>list</strong> requests by assembling the entire response in-memory before transmitting any data to the client.\nBut what if the response body is substantial, say hundreds of megabytes? Additionally, imagine a scenario where multiple <strong>list</strong> requests flood in simultaneously, perhaps after a brief network outage.\nWhile <a href=\"https://kubernetes.io/docs/concepts/cluster-administration/flow-control/\">API Priority and Fairness</a> has proven to reasonably protect kube-apiserver from CPU overload, its impact is visibly smaller for memory protection.\nThis can be explained by the differing nature of resource consumption by a single API request - the CPU usage at any given time is capped by a constant, whereas memory, being uncompressible, can grow proportionally with the number of processed objects and is unbounded.\nThis situation poses a genuine risk, potentially overwhelming and crashing any kube-apiserver within seconds due to out-of-memory (OOM) conditions. To better visualize the issue, let's consider the below graph.</p>\n<figure class=\"diagram-large clickable-zoom\">\n<img alt=\"Monitoring graph showing kube-apiserver memory usage\" src=\"https://kubernetes.io/blog/2024/12/17/kube-apiserver-api-streaming/kube-apiserver-memory_usage.png\" />\n</figure>\n<p>The graph shows the memory usage of a kube-apiserver during a synthetic test.\n(see the <a href=\"https://kubernetes.io/feed.xml#the-synthetic-test\">synthetic test</a> section for more details).\nThe results clearly show that increasing the number of informers significantly boosts the server's memory consumption.\nNotably, at approximately 16:40, the server crashed when serving only 16 informers.</p>\n<h2 id=\"why-does-kube-apiserver-allocate-so-much-memory-for-list-requests\">Why does kube-apiserver allocate so much memory for list requests?</h2>\n<p>Our investigation revealed that this substantial memory allocation occurs because the server before sending the first byte to the client must:</p>\n<ul>\n<li>fetch data from the database,</li>\n<li>deserialize the data from its stored format,</li>\n<li>and finally construct the final response by converting and serializing the data into a client requested format</li>\n</ul>\n<p>This sequence results in significant temporary memory consumption.\nThe actual usage depends on many factors like the page size, applied filters (e.g. label selectors), query parameters, and sizes of individual objects.</p>\n<p>Unfortunately, neither <a href=\"https://kubernetes.io/docs/concepts/cluster-administration/flow-control/\">API Priority and Fairness</a> nor Golang's garbage collection or Golang memory limits can prevent the system from exhausting memory under these conditions.\nThe memory is allocated suddenly and rapidly, and just a few requests can quickly deplete the available memory, leading to resource exhaustion.</p>\n<p>Depending on how the API server is run on the node, it might either be killed through OOM by the kernel when exceeding the configured memory limits during these uncontrolled spikes, or if limits are not configured it might have even worse impact on the control plane node.\nAnd worst, after the first API server failure, the same requests will likely hit another control plane node in an HA setup with probably the same impact.\nPotentially a situation that is hard to diagnose and hard to recover from.</p>\n<h2 id=\"streaming-list-requests\">Streaming list requests</h2>\n<p>Today, we're excited to announce a major improvement.\nWith the graduation of the <em>watch list</em> feature to beta in Kubernetes 1.32, client-go users can opt-in (after explicitly enabling <code>WatchListClient</code> feature gate)\nto streaming lists by switching from <strong>list</strong> to (a special kind of) <strong>watch</strong> requests.</p>\n<p><strong>Watch</strong> requests are served from the <em>watch cache</em>, an in-memory cache designed to improve scalability of read operations.\nBy streaming each item individually instead of returning the entire collection, the new method maintains constant memory overhead.\nThe API server is bound by the maximum allowed size of an object in etcd plus a few additional allocations.\nThis approach drastically reduces the temporary memory usage compared to traditional <strong>list</strong> requests, ensuring a more efficient and stable system,\nespecially in clusters with a large number of objects of a given type or large average object sizes where despite paging memory consumption used to be high.</p>\n<p>Building on the insight gained from the synthetic test (see the <a href=\"https://kubernetes.io/feed.xml#the-synthetic-test\">synthetic test</a>, we developed an automated performance test to systematically evaluate the impact of the <em>watch list</em> feature.\nThis test replicates the same scenario, generating a large number of Secrets with a large payload, and scaling the number of informers to simulate heavy <strong>list</strong> request patterns.\nThe automated test is executed periodically to monitor memory usage of the server with the feature enabled and disabled.</p>\n<p>The results showed significant improvements with the <em>watch list</em> feature enabled.\nWith the feature turned on, the kube-apiserver’s memory consumption stabilized at approximately <strong>2 GB</strong>.\nBy contrast, with the feature disabled, memory usage increased to approximately <strong>20GB</strong>, a <strong>10x</strong> increase!\nThese results confirm the effectiveness of the new streaming API, which reduces the temporary memory footprint.</p>\n<h2 id=\"enabling-api-streaming-for-your-component\">Enabling API Streaming for your component</h2>\n<p>Upgrade to Kubernetes 1.32. Make sure your cluster uses etcd in version 3.4.31+ or 3.5.13+.\nChange your client software to use watch lists. If your client code is written in Golang, you'll want to enable <code>WatchListClient</code> for client-go.\nFor details on enabling that feature, read <a href=\"https://kubernetes.io/blog/2024/08/12/feature-gates-in-client-go\">Introducing Feature Gates to Client-Go: Enhancing Flexibility and Control</a>.</p>\n<h2 id=\"what-s-next\">What's next?</h2>\n<p>In Kubernetes 1.32, the feature is enabled in kube-controller-manager by default despite its beta state.\nThis will eventually be expanded to other core components like kube-scheduler or kubelet; once the feature becomes generally available, if not earlier.\nOther 3rd-party components are encouraged to opt-in to the feature during the beta phase, especially when they are at risk of accessing a large number of resources or kinds with potentially large object sizes.</p>\n<p>For the time being, <a href=\"https://kubernetes.io/docs/concepts/cluster-administration/flow-control/\">API Priority and Fairness</a> assigns a reasonable small cost to <strong>list</strong> requests.\nThis is necessary to allow enough parallelism for the average case where <strong>list</strong> requests are cheap enough.\nBut it does not match the spiky exceptional situation of many and large objects.\nOnce the majority of the Kubernetes ecosystem has switched to <em>watch list</em>, the <strong>list</strong> cost estimation can be changed to larger values without risking degraded performance in the average case,\nand with that increasing the protection against this kind of requests that can still hit the API server in the future.</p>\n<h2 id=\"the-synthetic-test\">The synthetic test</h2>\n<p>In order to reproduce the issue, we conducted a manual test to understand the impact of <strong>list</strong> requests on kube-apiserver memory usage.\nIn the test, we created 400 Secrets, each containing 1 MB of data, and used informers to retrieve all Secrets.</p>\n<p>The results were alarming, only 16 informers were needed to cause the test server to run out of memory and crash, demonstrating how quickly memory consumption can grow under such conditions.</p>\n<p>Special shout out to <a href=\"https://github.com/deads2k\">@deads2k</a> for his help in shaping this feature.</p>",
      "timestamp": 1741428556.9202278,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Kubernetes v1.32 Adds A New CPU Manager Static Policy Option For Strict CPU Reservation",
      "link": "https://kubernetes.io/blog/2024/12/16/cpumanager-strict-cpu-reservation/",
      "published": "Mon, 16 Dec 2024 00:00:00 +0000",
      "summary": "<p>In Kubernetes v1.32, after years of community discussion, we are excited to introduce a\n<code>strict-cpu-reservation</code> option for the <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/#static-policy-options\">CPU Manager static policy</a>.\nThis feature is currently in alpha, with the associated policy hidden by default. You can only use the\npolicy if you explicitly enable the alpha behavior in your cluster.</p>\n<h2 id=\"understanding-the-feature\">Understanding the feature</h2>\n<p>The CPU Manager static policy is used to reduce latency or improve performance. The <code>reservedSystemCPUs</code> defines an explicit CPU set for OS system daemons and kubernetes system daemons. This option is designed for Telco/NFV type use cases where uncontrolled interrupts/timers may impact the workload performance. you can use this option to define the explicit cpuset for the system/kubernetes daemons as well as the interrupts/timers, so the rest CPUs on the system can be used exclusively for workloads, with less impact from uncontrolled interrupts/timers. More details of this parameter can be found on the <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/reserve-compute-resources/#explicitly-reserved-cpu-list\">Explicitly Reserved CPU List</a> page.</p>\n<p>If you want to protect your system daemons and interrupt processing, the obvious way is to use the <code>reservedSystemCPUs</code> option.</p>\n<p>However, until the Kubernetes v1.32 release, this isolation was only implemented for guaranteed\npods that made requests for a whole number of CPUs. At pod admission time, the kubelet only\ncompares the CPU <em>requests</em> against the allocatable CPUs. In Kubernetes, limits can be higher than\nthe requests; the previous implementation allowed burstable and best-effort pods to use up\nthe capacity of <code>reservedSystemCPUs</code>, which could then starve host OS services of CPU - and we\nknow that people saw this in real life deployments.\nThe existing behavior also made benchmarking (for both infrastructure and workloads) results inaccurate.</p>\n<p>When this new <code>strict-cpu-reservation</code> policy option is enabled, the CPU Manager static policy will not allow any workload to use the reserved system CPU cores.</p>\n<h2 id=\"enabling-the-feature\">Enabling the feature</h2>\n<p>To enable this feature, you need to turn on both the <code>CPUManagerPolicyAlphaOptions</code> feature gate and the <code>strict-cpu-reservation</code> policy option. And you need to remove the <code>/var/lib/kubelet/cpu_manager_state</code> file if it exists and restart kubelet.</p>\n<p>With the following kubelet configuration:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-yaml\"><span style=\"display: flex;\"><span><span style=\"color: #008000; font-weight: bold;\">kind</span>:<span style=\"color: #bbb;\"> </span>KubeletConfiguration<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">apiVersion</span>:<span style=\"color: #bbb;\"> </span>kubelet.config.k8s.io/v1beta1<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">featureGates</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span>...<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">CPUManagerPolicyOptions</span>:<span style=\"color: #bbb;\"> </span><span style=\"color: #a2f; font-weight: bold;\">true</span><span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">CPUManagerPolicyAlphaOptions</span>:<span style=\"color: #bbb;\"> </span><span style=\"color: #a2f; font-weight: bold;\">true</span><span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">cpuManagerPolicy</span>:<span style=\"color: #bbb;\"> </span>static<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">cpuManagerPolicyOptions</span>:<span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"> </span><span style=\"color: #008000; font-weight: bold;\">strict-cpu-reservation</span>:<span style=\"color: #bbb;\"> </span><span style=\"color: #b44;\">\"true\"</span><span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #008000; font-weight: bold;\">reservedSystemCPUs</span>:<span style=\"color: #bbb;\"> </span><span style=\"color: #b44;\">\"0,32,1,33,16,48\"</span><span style=\"color: #bbb;\">\n</span></span></span><span style=\"display: flex;\"><span><span style=\"color: #bbb;\"></span><span style=\"color: #00f; font-weight: bold;\">...</span><span style=\"color: #bbb;\">\n</span></span></span></code></pre></div><p>When <code>strict-cpu-reservation</code> is not set or set to false:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-console\"><span style=\"display: flex;\"><span><span style=\"color: #000080; font-weight: bold;\">#</span> cat /var/lib/kubelet/cpu_manager_state\n</span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">{\"policyName\":\"static\",\"defaultCpuSet\":\"0-63\",\"checksum\":1058907510}\n</span></span></span></code></pre></div><p>When <code>strict-cpu-reservation</code> is set to true:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-console\"><span style=\"display: flex;\"><span><span style=\"color: #000080; font-weight: bold;\">#</span> cat /var/lib/kubelet/cpu_manager_state\n</span></span><span style=\"display: flex;\"><span><span style=\"color: #888;\">{\"policyName\":\"static\",\"defaultCpuSet\":\"2-15,17-31,34-47,49-63\",\"checksum\":4141502832}\n</span></span></span></code></pre></div><h2 id=\"monitoring-the-feature\">Monitoring the feature</h2>\n<p>You can monitor the feature impact by checking the following CPU Manager counters:</p>\n<ul>\n<li><code>cpu_manager_shared_pool_size_millicores</code>: report shared pool size, in millicores (e.g. 13500m)</li>\n<li><code>cpu_manager_exclusive_cpu_allocation_count</code>: report exclusively allocated cores, counting full cores (e.g. 16)</li>\n</ul>\n<p>Your best-effort workloads may starve if the <code>cpu_manager_shared_pool_size_millicores</code> count is zero for prolonged time.</p>\n<p>We believe any pod that is required for operational purpose like a log forwarder should not run as best-effort, but you can review and adjust the amount of CPU cores reserved as needed.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Strict CPU reservation is critical for Telco/NFV use cases. It is also a prerequisite for enabling the all-in-one type of deployments where workloads are placed on nodes serving combined control+worker+storage roles.</p>\n<p>We want you to start using the feature and looking forward to your feedback.</p>\n<h2 id=\"further-reading\">Further reading</h2>\n<p>Please check out the <a href=\"https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/\">Control CPU Management Policies on the Node</a>\ntask page to learn more about the CPU Manager, and how it fits in relation to the other node-level resource managers.</p>\n<h2 id=\"getting-involved\">Getting involved</h2>\n<p>This feature is driven by the <a href=\"https://github.com/Kubernetes/community/blob/master/sig-node/README.md\">SIG Node</a>. If you are interested in helping develop this feature, sharing feedback, or participating in any other ongoing SIG Node projects, please attend the SIG Node meeting for more details.</p>",
      "timestamp": 1741428556.9202316,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Kubernetes v1.32: Memory Manager Goes GA",
      "link": "https://kubernetes.io/blog/2024/12/13/memory-manager-goes-ga/",
      "published": "Fri, 13 Dec 2024 00:00:00 +0000",
      "summary": "<p>With Kubernetes 1.32, the memory manager has officially graduated to General Availability (GA),\nmarking a significant milestone in the journey toward efficient and predictable memory allocation for containerized applications.\nSince Kubernetes v1.22, where it graduated to beta, the memory manager has proved itself reliable, stable and a good complementary feature for the\n<a href=\"https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/\">CPU Manager</a>.</p>\n<p>As part of kubelet's workload admission process,\nthe memory manager provides topology hints\nto optimize memory allocation and alignment.\nThis enables users to allocate exclusive\nmemory for Pods in the <a href=\"https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#guaranteed\">Guaranteed</a> QoS class.\nMore details about the process can be found in the memory manager goes to beta <a href=\"https://kubernetes.io/blog/2021/08/11/kubernetes-1-22-feature-memory-manager-moves-to-beta/\">blog</a>.</p>\n<p>Most of the changes introduced since the Beta are bug fixes, internal refactoring and\nobservability improvements, such as metrics and better logging.</p>\n<h2 id=\"observability-improvements\">Observability improvements</h2>\n<p>As part of the effort\nto increase the observability of memory manager, new metrics have been added\nto provide some statistics on memory allocation patterns.</p>\n<ul>\n<li>\n<p><strong>memory_manager_pinning_requests_total</strong> -\ntracks the number of times the pod spec required the memory manager to pin memory pages.</p>\n</li>\n<li>\n<p><strong>memory_manager_pinning_errors_total</strong> -\ntracks the number of times the pod spec required the memory manager\nto pin memory pages, but the allocation failed.</p>\n</li>\n</ul>\n<h2 id=\"improving-memory-manager-reliability-and-consistency\">Improving memory manager reliability and consistency</h2>\n<p>The kubelet does not guarantee pod ordering\nwhen admitting pods after a restart or reboot.</p>\n<p>In certain edge cases, this behavior could cause\nthe memory manager to reject some pods,\nand in more extreme cases, it may cause kubelet to fail upon restart.</p>\n<p>Previously, the beta implementation lacked certain checks and logic to prevent\nthese issues.</p>\n<p>To stabilize the memory manager for general availability (GA) readiness,\nsmall but critical refinements have been\nmade to the algorithm, improving its robustness and handling of edge cases.</p>\n<h2 id=\"future-development\">Future development</h2>\n<p>There is more to come for the future of Topology Manager in general,\nand memory manager in particular.\nNotably, ongoing efforts are underway\nto extend <a href=\"https://github.com/kubernetes/kubernetes/pull/128560\">memory manager support to Windows</a>,\nenabling CPU and memory affinity on a Windows operating system.</p>\n<h2 id=\"getting-involved\">Getting involved</h2>\n<p>This feature is driven by the <a href=\"https://github.com/Kubernetes/community/blob/master/sig-node/README.md\">SIG Node</a> community.\nPlease join us to connect with the community\nand share your ideas and feedback around the above feature and\nbeyond.\nWe look forward to hearing from you!</p>",
      "timestamp": 1741428556.9202356,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Kubernetes v1.32: QueueingHint Brings a New Possibility to Optimize Pod Scheduling",
      "link": "https://kubernetes.io/blog/2024/12/12/scheduler-queueinghint/",
      "published": "Thu, 12 Dec 2024 00:00:00 +0000",
      "summary": "<p>The Kubernetes <a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/\">scheduler</a> is the core\ncomponent that selects the nodes on which new Pods run. The scheduler processes\nthese new Pods <strong>one by one</strong>. Therefore, the larger your clusters, the more important\nthe throughput of the scheduler becomes.</p>\n<p>Over the years, Kubernetes SIG Scheduling has improved the throughput\nof the scheduler in multiple enhancements. This blog post describes a major improvement to the\nscheduler in Kubernetes v1.32: a\n<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/#extension-points\">scheduling context element</a>\nnamed <em>QueueingHint</em>. This page provides background knowledge of the scheduler and explains how\nQueueingHint improves scheduling throughput.</p>\n<h2 id=\"scheduling-queue\">Scheduling queue</h2>\n<p>The scheduler stores all unscheduled Pods in an internal component called the <em>scheduling queue</em>.</p>\n<p>The scheduling queue consists of the following data structures:</p>\n<ul>\n<li><strong>ActiveQ</strong>: holds newly created Pods or Pods that are ready to be retried for scheduling.</li>\n<li><strong>BackoffQ</strong>: holds Pods that are ready to be retried but are waiting for a backoff period to end. The\nbackoff period depends on the number of unsuccessful scheduling attempts performed by the scheduler on that Pod.</li>\n<li><strong>Unschedulable Pod Pool</strong>: holds Pods that the scheduler won't attempt to schedule for one of the\nfollowing reasons:\n<ul>\n<li>The scheduler previously attempted and was unable to schedule the Pods. Since that attempt, the cluster\nhasn't changed in a way that could make those Pods schedulable.</li>\n<li>The Pods are blocked from entering the scheduling cycles by PreEnqueue Plugins,\nfor example, they have a <a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/pod-scheduling-readiness/#configuring-pod-schedulinggates\">scheduling gate</a>,\nand get blocked by the scheduling gate plugin.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"scheduling-framework-and-plugins\">Scheduling framework and plugins</h2>\n<p>The Kubernetes scheduler is implemented following the Kubernetes\n<a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/scheduling-framework/\">scheduling framework</a>.</p>\n<p>And, all scheduling features are implemented as plugins\n(e.g., <a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity\">Pod affinity</a>\nis implemented in the <code>InterPodAffinity</code> plugin.)</p>\n<p>The scheduler processes pending Pods in phases called <em>cycles</em> as follows:</p>\n<ol>\n<li>\n<p><strong>Scheduling cycle</strong>: the scheduler takes pending Pods from the activeQ component of the scheduling\nqueue <em>one by one</em>. For each Pod, the scheduler runs the filtering/scoring logic from every scheduling plugin. The\nscheduler then decides on the best node for the Pod, or decides that the Pod can't be scheduled at that time.</p>\n<p>If the scheduler decides that a Pod can't be scheduled, that Pod enters the Unschedulable Pod Pool\ncomponent of the scheduling queue. However, if the scheduler decides to place the Pod on a node,\nthe Pod goes to the binding cycle.</p>\n</li>\n<li>\n<p><strong>Binding cycle</strong>: the scheduler communicates the node placement decision to the Kubernetes API\nserver. This operation bounds the Pod to the selected node.</p>\n</li>\n</ol>\n<p>Aside from some exceptions, most unscheduled Pods enter the unschedulable pod pool after each scheduling\ncycle. The Unschedulable Pod Pool component is crucial because of how the scheduling cycle processes Pods one by one. If the scheduler had to constantly retry placing unschedulable Pods, instead of offloading those\nPods to the Unschedulable Pod Pool, multiple scheduling cycles would be wasted on those Pods.</p>\n<h2 id=\"improvements-to-retrying-pod-scheduling-with-queuinghint\">Improvements to retrying Pod scheduling with QueuingHint</h2>\n<p>Unschedulable Pods only move back into the ActiveQ or BackoffQ components of the scheduling\nqueue if changes in the cluster might allow the scheduler to place those Pods on nodes.</p>\n<p>Prior to v1.32, each plugin registered which cluster changes could solve their failures, an object creation, update, or deletion in the cluster (called <em>cluster events</em>),\nwith <code>EnqueueExtensions</code> (<code>EventsToRegister</code>),\nand the scheduling queue retries a pod with an event that is registered by a plugin that rejected the pod in a previous scheduling cycle.</p>\n<p>Additionally, we had an internal feature called <code>preCheck</code>, which helped further filtering of events for efficiency, based on Kubernetes core scheduling constraints;\nFor example, <code>preCheck</code> could filter out node-related events when the node status is <code>NotReady</code>.</p>\n<p>However, we had two issues for those approaches:</p>\n<ul>\n<li>Requeueing with events was too broad, could lead to scheduling retries for no reason.\n<ul>\n<li>A new scheduled Pod <em>might</em> solve the <code>InterPodAffinity</code>'s failure, but not all of them do.\nFor example, if a new Pod is created, but without a label matching <code>InterPodAffinity</code> of the unschedulable pod, the pod wouldn't be schedulable.</li>\n</ul>\n</li>\n<li><code>preCheck</code> relied on the logic of in-tree plugins and was not extensible to custom plugins,\nlike in issue <a href=\"https://github.com/kubernetes/kubernetes/issues/110175\">#110175</a>.</li>\n</ul>\n<p>Here QueueingHints come into play;\na QueueingHint subscribes to a particular kind of cluster event, and make a decision about whether each incoming event could make the Pod schedulable.</p>\n<p>For example, consider a Pod named <code>pod-a</code> that has a required Pod affinity. <code>pod-a</code> was rejected in\nthe scheduling cycle by the <code>InterPodAffinity</code> plugin because no node had an existing Pod that matched\nthe Pod affinity specification for <code>pod-a</code>.</p>\n<figure>\n<img alt=\"A diagram showing the scheduling queue and pod-a rejected by InterPodAffinity plugin\" src=\"https://kubernetes.io/blog/2024/12/12/scheduler-queueinghint/queueinghint1.svg\" /> <figcaption>\n<p>A diagram showing the scheduling queue and pod-a rejected by InterPodAffinity plugin</p>\n</figcaption>\n</figure>\n<p><code>pod-a</code> moves into the Unschedulable Pod Pool. The scheduling queue records which plugin caused\nthe scheduling failure for the Pod. For <code>pod-a</code>, the scheduling queue records that the <code>InterPodAffinity</code>\nplugin rejected the Pod.</p>\n<p><code>pod-a</code> will never be schedulable until the InterPodAffinity failure is resolved.\nThere're some scenarios that the failure could be resolved, one example is an existing running pod gets a label update and becomes matching a Pod affinity.\nFor this scenario, the <code>InterPodAffinity</code> plugin's <code>QueuingHint</code> callback function checks every Pod label update that occurs in the cluster.\nThen, if a Pod gets a label update that matches the Pod affinity requirement of <code>pod-a</code>, the <code>InterPodAffinity</code>,\nplugin's <code>QueuingHint</code> prompts the scheduling queue to move <code>pod-a</code> back into the ActiveQ or\nthe BackoffQ component.</p>\n<figure>\n<img alt=\"A diagram showing the scheduling queue and pod-a being moved by InterPodAffinity QueueingHint\" src=\"https://kubernetes.io/blog/2024/12/12/scheduler-queueinghint/queueinghint2.svg\" /> <figcaption>\n<p>A diagram showing the scheduling queue and pod-a being moved by InterPodAffinity QueueingHint</p>\n</figcaption>\n</figure>\n<h2 id=\"queueinghint-s-history-and-what-s-new-in-v1-32\">QueueingHint's history and what's new in v1.32</h2>\n<p>At SIG Scheduling, we have been working on the development of QueueingHint since\nKubernetes v1.28.</p>\n<p>While QueuingHint isn't user-facing, we implemented the <code>SchedulerQueueingHints</code> feature gate as a\nsafety measure when we originally added this feature. In v1.28, we implemented QueueingHints with a\nfew in-tree plugins experimentally, and made the feature gate enabled by default.</p>\n<p>However, users reported a memory leak, and consequently we disabled the feature gate in a\npatch release of v1.28. From v1.28 until v1.31, we kept working on the QueueingHint implementation\nwithin the rest of the in-tree plugins and fixing bugs.</p>\n<p>In v1.32, we made this feature enabled by default again. We finished implementing QueueingHints\nin all plugins and also identified the cause of the memory leak!</p>\n<p>We thank all the contributors who participated in the development of this feature and those who reported and investigated the earlier issues.</p>\n<h2 id=\"getting-involved\">Getting involved</h2>\n<p>These features are managed by Kubernetes <a href=\"https://github.com/kubernetes/community/tree/master/sig-scheduling\">SIG Scheduling</a>.</p>\n<p>Please join us and share your feedback.</p>\n<h2 id=\"how-can-i-learn-more\">How can I learn more?</h2>\n<ul>\n<li><a href=\"https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/4247-queueinghint/README.md\">KEP-4247: Per-plugin callback functions for efficient requeueing in the scheduling queue</a></li>\n</ul>",
      "timestamp": 1741428556.9202392,
      "translated": false
    },
    {
      "feed_name": "Kubernetes Blog",
      "source_language": "en",
      "title": "Kubernetes v1.32: Penelope",
      "link": "https://kubernetes.io/blog/2024/12/11/kubernetes-v1-32-release/",
      "published": "Wed, 11 Dec 2024 00:00:00 +0000",
      "summary": "<p><strong>Editors:</strong> Matteo Bianchi, Edith Puclla, William Rizzo, Ryota Sawada, Rashan Smith</p>\n<p>Announcing the release of Kubernetes v1.32: Penelope!</p>\n<p>In line with previous releases, the release of Kubernetes v1.32 introduces new stable, beta, and alpha features.\nThe consistent delivery of high-quality releases underscores the strength of our development cycle and the vibrant\nsupport from our community.\nThis release consists of 44 enhancements in total.\nOf those enhancements, 13 have graduated to Stable, 12 are entering Beta, and 19 have entered in Alpha.</p>\n<h2 id=\"release-theme-and-logo\">Release theme and logo</h2>\n<figure class=\"release-logo \">\n<img alt=\"Kubernetes v1.32 logo: Penelope from the Odyssey, a helm and a purple geometric background\" src=\"https://kubernetes.io/blog/2024/12/11/kubernetes-v1-32-release/k8s-1.32.png\" />\n</figure>\n<p>The Kubernetes v1.32 Release Theme is &quot;Penelope&quot;.</p>\n<p>If Kubernetes is Ancient Greek for &quot;pilot&quot;, in this release we start from that origin\nand reflect on the last 10 years of Kubernetes and our accomplishments:\neach release cycle is a journey, and just like Penelope, in &quot;The Odyssey&quot;,<br />\nweaved for 10 years -- each night removing parts of what she had done during the day --\nso does each release add new features and removes others, albeit here with a much\nclearer purpose of constantly improving Kubernetes.\nWith v1.32 being the last release in the year Kubernetes marks its first decade anniversary,\nwe wanted to honour all of those that have been part of the global Kubernetes crew\nthat roams the cloud-native seas through perils and challanges:\nmay we continue to weave the future of Kubernetes together.</p>\n<h2 id=\"updates-to-recent-key-features\">Updates to recent key features</h2>\n<h3 id=\"a-note-on-dra-enhancements\">A note on DRA enhancements</h3>\n<p>In this release, like the previous one, the Kubernetes project continues proposing a number of enhancements to the\nDynamic Resource Allocation (DRA), a key component of the Kubernetes resource management system. These enhancements aim\nto improve the flexibility and efficiency of resource allocation for workloads that require specialized hardware, such\nas GPUs, FPGAs and network adapters.\nThese features are particularly useful for use-cases such as machine learning or high-performance computing\napplications. The core part enabling DRA Structured parameter support <a href=\"https://kubernetes.io/feed.xml#structured-parameter-support\">got promoted to beta</a>.</p>\n<h3 id=\"quality-of-life-improvements-on-nodes-and-sidecar-containers-update\">Quality of life improvements on nodes and sidecar containers update</h3>\n<p><a href=\"https://github.com/kubernetes/community/tree/master/sig-node\">SIG Node</a> has the following highlights that go beyond\nKEPs:</p>\n<ol>\n<li>\n<p>The systemd watchdog capability is now used to restart the kubelet when its health check fails, while also limiting\nthe maximum number of restarts within a given time period. This enhances the reliability of the kubelet. For more\ndetails, see pull request <a href=\"https://github.com/kubernetes/kubernetes/pull/127566\">#127566</a>.</p>\n</li>\n<li>\n<p>In cases when an image pull back-off error is encountered, the message displayed in the Pod status has been improved\nto be more human-friendly and to indicate details about why the Pod is in this condition.\nWhen an image pull back-off occurs, the error is appended to the <code>status.containerStatuses[*].state.waiting.message</code>\nfield in the Pod specification with an <code>ImagePullBackOff</code> value in the <code>reason</code> field. This change provides you with\nmore context and helps you to identify the root cause of the issue. For more details, see pull request\n<a href=\"https://github.com/kubernetes/kubernetes/pull/127918\">#127918</a>.</p>\n</li>\n<li>\n<p>The sidecar containers feature is targeting graduation to Stable in v1.33. To view the remaining work items and\nfeedback from users, see comments in the issue\n<a href=\"https://github.com/kubernetes/enhancements/issues/753#issuecomment-2350136594\">#753</a>.</p>\n</li>\n</ol>\n<h2 id=\"highlights-of-features-graduating-to-stable\">Highlights of features graduating to Stable</h2>\n<p><em>This is a selection of some of the improvements that are now stable following the v1.32 release.</em></p>\n<h3 id=\"custom-resource-field-selectors\">Custom Resource field selectors</h3>\n<p>Custom resource field selector allows developers to add field selectors to custom resources, mirroring the functionality\navailable for built-in Kubernetes objects. This allows for more efficient and precise filtering of custom resources,\npromoting better API design practices.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/4358\">KEP #4358</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-api-machinery\">SIG API\nMachinery</a>.</p>\n<h3 id=\"support-to-size-memory-backed-volumes\">Support to size memory backed volumes</h3>\n<p>This feature makes it possible to dynamically size memory-backed volumes based on Pod resource limits, improving the\nworkload's portability and overall node resource utilization.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/1967\">KEP #1967</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-node\">SIG\nNode</a>.</p>\n<h3 id=\"bound-service-account-token-improvement\">Bound service account token improvement</h3>\n<p>The inclusion of the node name in the service account token claims allows users to use such information during\nauthorization and admission (ValidatingAdmissionPolicy).\nFurthermore this improvement keeps service account credentials from being a privilege escalation path for nodes.</p>\n<p>This work was done as part of <a href=\"https://github.com/kubernetes/enhancements/issues/4193\">KEP #4193</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-auth\">SIG\nAuth</a>.</p>\n<h3 id=\"structured-authorization-configuration\">Structured authorization configuration</h3>\n<p>Multiple authorizers can be configured in the API server to allow for structured authorization decisions,\nwith support for CEL match conditions in webhooks.\nThis work was done as part of <a href=\"https://github.com/kubernetes/enhancements/issues/3221\">KEP #3221</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-auth\">SIG\nAuth</a>.</p>\n<h3 id=\"auto-remove-pvcs-created-by-statefulset\">Auto remove PVCs created by StatefulSet</h3>\n<p>PersistentVolumeClaims (PVCs) created by StatefulSets get automatically deleted when no longer needed,\nwhile ensuring data persistence during StatefulSet updates and node maintenance.\nThis feature simplifies storage management for StatefulSets and reduces the risk of orphaned PVCs.</p>\n<p>This work was done as part of <a href=\"https://github.com/kubernetes/enhancements/issues/1847\">KEP #1847</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-apps\">SIG\nApps</a>.</p>\n<h2 id=\"highlights-of-features-graduating-to-beta\">Highlights of features graduating to Beta</h2>\n<p><em>This is a selection of some of the improvements that are now beta following the v1.32 release.</em></p>\n<h3 id=\"job-api-managed-by-mechanism\">Job API managed-by mechanism</h3>\n<p>The <code>managedBy</code> field for Jobs was promoted to beta in the v1.32 release. This feature enables external controllers\n(like <a href=\"https://kueue.sigs.k8s.io/\">Kueue</a>) to manage Job synchronization, offering greater flexibility and integration\nwith advanced workload management systems.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/4368\">KEP #4368</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-apps\">SIG\nApps</a>.</p>\n<h3 id=\"only-allow-anonymous-auth-for-configured-endpoints\">Only allow anonymous auth for configured endpoints</h3>\n<p>This feature lets admins specify which endpoints are allowed for anonymous requests. For example, the admin\ncan choose to only allow anonymous access to health endpoints like <code>/healthz</code>, <code>/livez</code>, and <code>/readyz</code> while\nmaking sure preventing anonymous access to other cluster endpoints or resources even if a user\nmisconfigures RBAC.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/4633\">KEP #4633</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-auth\">SIG\nAuth</a>.</p>\n<h3 id=\"per-plugin-callback-functions-for-accurate-requeueing-in-kube-scheduler-enhancements\">Per-plugin callback functions for accurate requeueing in kube-scheduler enhancements</h3>\n<p>This feature enhances scheduling throughput with more efficient scheduling retry decisions by\nper-plugin callback functions (QueueingHint). All plugins now have QueueingHints.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/4247\">KEP #4247</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-scheduling\">SIG\nScheduling</a>.</p>\n<h3 id=\"recover-from-volume-expansion-failure\">Recover from volume expansion failure</h3>\n<p>This feature lets users recover from volume expansion failure by retrying with a smaller size. This enhancement ensures\nthat volume expansion is more resilient and reliable, reducing the risk of data loss or corruption during the process.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/1790\">KEP #1790</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-storage\">SIG\nStorage</a>.</p>\n<h3 id=\"volume-group-snapshot\">Volume group snapshot</h3>\n<p>This feature introduces a VolumeGroupSnapshot API, which lets users take a snapshot of multiple volumes together, ensuring data consistency across the volumes.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/3476\">KEP #3476</a>, by <a href=\"https://github.com/kubernetes/community/tree/master/sig-storage\">SIG\nStorage</a>.</p>\n<h3 id=\"structured-parameter-support\">Structured parameter support</h3>\n<p>The core part of Dynamic Resource Allocation (DRA), the structured parameter support, got promoted to beta.\nThis allows the kube-scheduler and Cluster Autoscaler to simulate claim allocation directly, without needing a\nthird-party driver.\nThese components can now predict whether resource requests can be fulfilled based on the cluster's current state without actually\ncommitting to the allocation. By eliminating the need for a third-party driver to validate or test allocations, this\nfeature improves planning and decision-making for resource distribution, making the scheduling and scaling processes\nmore efficient.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/4381\">KEP #4381</a>, by WG Device\nManagement (a cross functional team containing <a href=\"https://github.com/kubernetes/community/tree/master/sig-node\">SIG Node</a>,\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-scheduling\">SIG Scheduling</a> and <a href=\"https://github.com/kubernetes/community/tree/master/sig-autoscaling\">SIG\nAutoscaling</a>).</p>\n<h3 id=\"label-and-field-selector-authorization\">Label and field selector authorization</h3>\n<p>Label and field selectors can be used in authorization decisions. The node authorizer\nautomatically takes advantage of this to limit nodes to list or watch their pods only.\nWebhook authorizers can be updated to limit requests based on the label or field selector used.</p>\n<p>This work was done as part of <a href=\"https://github.com/kubernetes/enhancements/issues/4601\">KEP #4601</a>\nby <a href=\"https://github.com/kubernetes/community/tree/master/sig-auth\">SIG Auth</a>.</p>\n<h2 id=\"highlights-of-new-features-in-alpha\">Highlights of new features in Alpha</h2>\n<p><em>This is a selection of key improvements introduced as alpha features in the v1.32 release.</em></p>\n<h3 id=\"asynchronous-preemption-in-the-kubernetes-scheduler\">Asynchronous preemption in the Kubernetes Scheduler</h3>\n<p>The Kubernetes scheduler has been enhanced with Asynchronous Preemption, a feature that improves scheduling throughput\nby handling preemption operations asynchronously. Preemption ensures higher-priority pods get the resources they need by\nevicting lower-priority ones, but this process previously involved heavy operations like API calls to delete pods,\nslowing down the scheduler. With this enhancement, such tasks are now processed in parallel, allowing the scheduler to\ncontinue scheduling other pods without delays.\nThis improvement is particularly beneficial in clusters with high Pod churn or frequent scheduling failures, ensuring a\nmore efficient and resilient scheduling process.</p>\n<p>This work was done as a part of KEP <a href=\"https://github.com/kubernetes/enhancements/issues/4832\">#4832</a>\nby <a href=\"https://github.com/kubernetes/community/tree/master/sig-scheduling\">SIG Scheduling</a>.</p>\n<h3 id=\"mutating-admission-policies-using-cel-expressions\">Mutating admission policies using CEL expressions</h3>\n<p>This feature leverages CEL's object instantiation and JSON Patch strategies, combined with Server Side Apply’s merge\nalgorithms. It simplifies policy definition, reduces mutation conflicts, and enhances admission control performance\nwhile laying a foundation for more robust, extensible policy frameworks in Kubernetes.</p>\n<p>The Kubernetes API server now supports Common Expression Language (CEL)-based Mutating Admission Policies, providing a\nlightweight, efficient alternative to mutating admission webhooks. With this enhancement, administrators can use CEL to\ndeclare mutations like setting labels, defaulting fields, or injecting sidecars with simple, declarative expressions.\nThis approach reduces operational complexity, eliminates the need for webhooks, and integrates directly with the\nkube-apiserver, offering faster and more reliable in-process mutation handling.</p>\n<p>This work was done as a part of <a href=\"https://github.com/kubernetes/enhancements/issues/3962\">KEP #3962</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-api-machinery\">SIG API\nMachinery</a>.</p>\n<h3 id=\"pod-level-resource-specifications\">Pod-level resource specifications</h3>\n<p>This enhancement simplifies resource management in Kubernetes by introducing the ability to set resource requests and\nlimits at the Pod level, creating a shared pool that all containers in the Pod can dynamically use. This is particularly\nvaluable for workloads with containers that have fluctuating or bursty resource needs, as it minimizes over-provisioning\nand improves overall resource efficiency.</p>\n<p>By leveraging Linux cgroup settings at the Pod level, Kubernetes ensures that these resource limits are enforced while\nenabling tightly coupled containers to collaborate more effectively without hitting artificial constraints. Importantly,\nthis feature maintains backward compatibility with existing container-level resource settings, allowing users to adopt\nit incrementally without disrupting current workflows or existing configurations.</p>\n<p>This marks a significant improvement for multi-container pods, as it reduces the operational complexity of managing\nresource allocations across containers. It also provides a performance boost for tightly integrated applications, such\nas sidecar architectures, where containers share workloads or depend on each other’s availability to perform optimally.</p>\n<p>This work was done as part of <a href=\"https://github.com/kubernetes/enhancements/issues/2837\">KEP #2837</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-node\">SIG\nNode</a>.</p>\n<h3 id=\"allow-zero-value-for-sleep-action-of-prestop-hook\">Allow zero value for sleep action of PreStop hook</h3>\n<p>This enhancement introduces the ability to set a zero-second sleep duration for the PreStop lifecycle hook in\nKubernetes, offering a more flexible and no-op option for resource validation and customization. Previously, attempting\nto define a zero value for the sleep action resulted in validation errors, restricting its use. With this update, users\ncan configure a zero-second duration as a valid sleep setting, enabling immediate execution and termination behaviors\nwhere needed.</p>\n<p>The enhancement is backward-compatible, introduced as an opt-in feature controlled by the\n<code>PodLifecycleSleepActionAllowZero</code> feature gate. This change is particularly beneficial for scenarios requiring PreStop\nhooks for validation or admission webhook processing without requiring an actual sleep duration. By aligning with the\ncapabilities of the <code>time.After</code> Go function, this update simplifies configuration and expands usability for Kubernetes\nworkloads.</p>\n<p>This work was done as part of <a href=\"https://github.com/kubernetes/enhancements/issues/4818\">KEP #4818</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-node\">SIG\nNode</a>.</p>\n<h3 id=\"dra-standardized-network-interface-data-for-resource-claim-status\">DRA: Standardized network interface data for resource claim status</h3>\n<p>This enhancement adds a new field that allows drivers to report specific device status data for each allocated object\nin a ResourceClaim. It also establishes a standardized way to represent networking devices information.</p>\n<p>This work was done as a part of\n<a href=\"https://github.com/kubernetes/enhancements/issues/4817\">KEP #4817</a>, by\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-network\">SIG Network</a>.</p>\n<h3 id=\"new-statusz-and-flagz-endpoints-for-core-components\">New statusz and flagz endpoints for core components</h3>\n<p>You can enable two new HTTP endpoints, <code>/statusz</code> and <code>/flagz</code>, for core components.\nThese enhance cluster debuggability by gaining insight into what versions (e.g. Golang version) that component is\nrunning as, along with details about its uptime, and which command line flags that component was executed with;\nmaking it easier to diagnose both runtime and configuration issues.</p>\n<p>This work was done as part of\n<a href=\"https://github.com/kubernetes/enhancements/issues/4827\">KEP #4827</a>\nand <a href=\"https://github.com/kubernetes/enhancements/issues/4828\">KEP #4828</a> by\n<a href=\"https://github.com/kubernetes/community/tree/master/sig-instrumentation\">SIG Instrumentation</a>.</p>\n<h3 id=\"windows-strikes-back\">Windows strikes back!</h3>\n<p>Support for graceful shutdowns of Windows nodes in Kubernetes clusters has been added.\nBefore this release, Kubernetes provided graceful node shutdown functionality for Linux nodes\nbut lacked equivalent support for Windows. This enhancement enables the kubelet on Windows nodes to handle system\nshutdown events properly. Doing so, it ensures that Pods running on Windows nodes are gracefully terminated,\nallowing workloads to be rescheduled without disruption. This improvement enhances the reliability and stability\nof clusters that include Windows nodes, especially during a planned maintenance or any system updates.</p>\n<p>Moreover CPU and memory affinity support has been added for Windows nodes with nodes, with improvements\nto the CPU manager, memory manager and topology manager.</p>\n<p>This work was done respectively as part of <a href=\"https://github.com/kubernetes/enhancements/issues/4802\">KEP #4802</a>\nand <a href=\"https://github.com/kubernetes/enhancements/issues/4885\">KEP #4885</a> by <a href=\"https://github.com/kubernetes/community/tree/master/sig-windows\">SIG\nWindows</a>.</p>\n<h2 id=\"graduations-deprecations-and-removals-in-1-32\">Graduations, deprecations, and removals in 1.32</h2>\n<h3 id=\"graduations-to-stable\">Graduations to Stable</h3>\n<p>This lists all the features that graduated to stable (also known as <em>general availability</em>). For a full list of updates\nincluding new features and graduations from alpha to beta, see the release notes.</p>\n<p>This release includes a total of 13 enhancements promoted to Stable:</p>\n<ul>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/3221\">Structured Authorization Configuration</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/4193\">Bound service account token improvements</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/4358\">Custom Resource Field Selectors</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/4420\">Retry Generate Name</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/1860\">Make Kubernetes aware of the LoadBalancer behaviour</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/2681\">Field <code>status.hostIPs</code> added for Pod</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/4292\">Custom profile in kubectl debug</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/1769\">Memory Manager</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/1967\">Support to size memory backed volumes</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/3545\">Improved multi-numa alignment in Topology Manager</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/4026\">Add job creation timestamp to job annotations</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/4017\">Add Pod Index Label for StatefulSets and Indexed Jobs</a></li>\n<li><a href=\"https://github.com/kubernetes/enhancements/issues/1847\">Auto remove PVCs created by StatefulSet</a></li>\n</ul>\n<h3 id=\"deprecations-and-removals\">Deprecations and removals</h3>\n<p>As Kubernetes develops and matures, features may be deprecated, removed, or replaced with better ones for the project's\noverall health.\nSee the Kubernetes <a href=\"https://kubernetes.io/docs/reference/using-api/deprecation-policy/\">deprecation and removal policy</a> for more details on\nthis process.</p>\n<h4 id=\"withdrawal-of-the-old-dra-implementation\">Withdrawal of the old DRA implementation</h4>\n<p>The enhancement <a href=\"https://github.com/kubernetes/enhancements/issues/3063\">#3063</a> introduced Dynamic Resource Allocation\n(DRA) in Kubernetes 1.26.</p>\n<p>However, in Kubernetes v1.32, this approach to DRA will be significantly changed. Code related to the original\nimplementation will be removed, leaving KEP <a href=\"https://github.com/kubernetes/enhancements/issues/4381\">#4381</a> as the &quot;new&quot;\nbase functionality.</p>\n<p>The decision to change the existing approach originated from its incompatibility with cluster autoscaling as resource\navailability was non-transparent, complicating decision-making for both Cluster Autoscaler and controllers.\nThe newly added Structured Parameter model substitutes the functionality.</p>\n<p>This removal will allow Kubernetes to handle new hardware requirements and resource claims more predictably, bypassing\nthe complexities of back and forth API calls to the kube-apiserver.</p>\n<p>See the enhancement issue <a href=\"https://github.com/kubernetes/enhancements/issues/3063\">#3063</a> to find out more.</p>\n<h4 id=\"api-removals\">API removals</h4>\n<p>There is one API removal in <a href=\"https://kubernetes.io/docs/reference/using-api/deprecation-guide/#v1-32\">Kubernetes v1.32</a>:</p>\n<ul>\n<li>The <code>flowcontrol.apiserver.k8s.io/v1beta3</code> API version of FlowSchema and PriorityLevelConfiguration has been removed.\nTo prepare for this, you can edit your existing manifests and rewrite client software to use the\n<code>flowcontrol.apiserver.k8s.io/v1 API</code> version, available since v1.29.\nAll existing persisted objects are accessible via the new API. Notable changes in flowcontrol.apiserver.k8s.io/v1beta3\ninclude that the PriorityLevelConfiguration <code>spec.limited.nominalConcurrencyShares</code> field only defaults to 30 when\nunspecified, and an explicit value of 0 is not changed to 30.</li>\n</ul>\n<p>For more information, refer to the <a href=\"https://kubernetes.io/docs/reference/using-api/deprecation-guide/#v1-32\">API deprecation guide</a>.</p>\n<h3 id=\"release-notes-and-upgrade-actions-required\">Release notes and upgrade actions required</h3>\n<p>Check out the full details of the Kubernetes v1.32 release in our <a href=\"https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.32.md\">release\nnotes</a>.</p>\n<h2 id=\"availability\">Availability</h2>\n<p>Kubernetes v1.32 is available for download on <a href=\"https://github.com/kubernetes/kubernetes/releases/tag/v1.32.0\">GitHub</a> or\non the <a href=\"https://kubernetes.io/releases/download/\">Kubernetes download page</a>.</p>\n<p>To get started with Kubernetes, check out these <a href=\"https://kubernetes.io/docs/tutorials/\">interactive tutorials</a> or run local Kubernetes\nclusters using <a href=\"https://minikube.sigs.k8s.io/\">minikube</a>. You can also easily install v1.32 using\n<a href=\"https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/\">kubeadm</a>.</p>\n<h2 id=\"release-team\">Release team</h2>\n<p>Kubernetes is only possible with the support, commitment, and hard work of its community.\nEach release team is made up of dedicated community volunteers who work together to build the many pieces that make up\nthe Kubernetes releases you rely on.\nThis requires the specialized skills of people from all corners of our community, from the code itself to its\ndocumentation and project management.</p>\n<p>We would like to thank the entire <a href=\"https://github.com/kubernetes/sig-release/blob/master/releases/release-1.32/release-team.md\">release\nteam</a> for the hours spent\nhard at work to deliver the Kubernetes v1.32 release to our community.\nThe Release Team's membership ranges from first-time shadows to returning team leads with experience forged over several\nrelease cycles.\nA very special thanks goes out our release lead, Frederico Muñoz, for leading the release team so gracefully and handle\nany matter with the uttermost care, making sure this release was executed smoothly and efficiently.\nLast but not least a big thanks goes to all the release members - leads and shadows alike - and to the following SIGs\nfor the terrific work and outcome achieved during these 14 weeks of release work:</p>\n<ul>\n<li><a href=\"https://github.com/kubernetes/community/tree/master/sig-docs\">SIG Docs</a> - for the fundamental support in docs and\nblog reviews and continous collaboration with release Comms and Docs;</li>\n<li><a href=\"https://github.com/kubernetes/community/tree/master/sig-k8s-infra\">SIG k8s Infra</a> and <a href=\"https://github.com/kubernetes/community/tree/master/sig-testing\">SIG\nTesting</a> - for the outstanding work in keeping the\ntesting framework in check, along with all the infra components necessary;</li>\n<li><a href=\"https://github.com/kubernetes/community/tree/master/sig-release\">SIG Release</a> and\nall the release managers - for the incredible support provided throughout the orchestration of the entire release,\naddressing even the most challenging issues in a graceful and timely manner.</li>\n</ul>\n<h2 id=\"project-velocity\">Project velocity</h2>\n<p>The CNCF K8s <a href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&amp;var-period=m&amp;var-repogroup_name=All\">DevStats\nproject</a>\naggregates a number of interesting data points related to the velocity of Kubernetes and various sub-projects. This\nincludes everything from individual contributions to the number of companies that are contributing and is an\nillustration of the depth and breadth of effort that goes into evolving this ecosystem.</p>\n<p>In the v1.32 release cycle, which ran for 14 weeks (September 9th to December 11th), we saw contributions to Kubernetes\nfrom as many as 125 different companies and 559 individuals as of writing.</p>\n<p>In the whole Cloud Native ecosystem, the figure goes up to 433 companies counting 2441 total contributors. This sees an\nincrease of 7% more overall contributions compared to the <a href=\"https://kubernetes.io/blog/2024/08/13/kubernetes-v1-31-release/#project-velocity\">previous\nrelease</a> cycle, along with 14%\nincrease in the number of companies involved, showcasing strong interest and community behind the Cloud Native projects.</p>\n<p>Source for this data:</p>\n<ul>\n<li><a href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&amp;from=1725832800000&amp;to=1733961599000&amp;var-period=d28&amp;var-repogroup_name=Kubernetes&amp;var-repo_name=kubernetes%2Fkubernetes\">Companies contributing to\nKubernetes</a></li>\n<li><a href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&amp;from=1725832800000&amp;to=1733961599000&amp;var-period=d28&amp;var-repogroup_name=All&amp;var-repo_name=kubernetes%2Fkubernetes\">Overall ecosystem\ncontributions</a></li>\n</ul>\n<p>By contribution we mean when someone makes a commit, code review, comment, creates an issue or PR, reviews a PR\n(including blogs and documentation) or comments on issues and PRs.</p>\n<p>If you are interested in contributing visit <a href=\"https://www.kubernetes.dev/docs/guide/#getting-started\">Getting Started</a> on\nour contributor website.</p>\n<p><a href=\"https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&amp;var-period=m&amp;var-repogroup_name=All\">Check out\nDevStats</a>\nto learn more about the overall velocity of the Kubernetes project and community.</p>\n<h2 id=\"event-updates\">Event updates</h2>\n<p>Explore the upcoming Kubernetes and cloud-native events from March to June 2025, featuring KubeCon and KCD Stay informed\nand engage with the Kubernetes community.</p>\n<p><strong>March 2025</strong></p>\n<ul>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Beijing, China</strong></a>: In March | Beijing, China</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Guadalajara, Mexico</strong></a>: March 16, 2025 | Guadalajara,\nMexico</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Rio de Janeiro, Brazil</strong></a>: March 22, 2025 | Rio de\nJaneiro, Brazil</li>\n</ul>\n<p><strong>April 2025</strong></p>\n<ul>\n<li><a href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-europe\"><strong>KubeCon + CloudNativeCon Europe 2025</strong></a>: April\n1-4, 2025 | London, United Kingdom</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Budapest, Hungary</strong></a>: April 23, 2025 | Budapest,\nHungary</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Chennai, India</strong></a>: April 26, 2025 | Chennai, India</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Auckland, New Zealand</strong></a>: April 28, 2025 | Auckland,\nNew Zealand</li>\n</ul>\n<p><strong>May 2025</strong></p>\n<ul>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Helsinki, Finland</strong></a>: May 6, 2025 | Helsinki, Finland</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: San Francisco, USA</strong></a>: May 8, 2025 | San Francisco, USA</li>\n<li><a href=\"https://community.cncf.io/events/details/cncf-kcd-texas-presents-kcd-texas-austin-2025/\"><strong>KCD - Kubernetes Community Days: Austin,\nUSA</strong></a>: May 15, 2025 | Austin,\nUSA</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Seoul, South Korea</strong></a>: May 22, 2025 | Seoul, South\nKorea</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Istanbul, Turkey</strong></a>: May 23, 2025 | Istanbul, Turkey</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Heredia, Costa Rica</strong></a>: May 31, 2025 | Heredia, Costa\nRica</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: New York, USA</strong></a>: In May | New York, USA</li>\n</ul>\n<p><strong>June 2025</strong></p>\n<ul>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Bratislava, Slovakia</strong></a>: June 5, 2025 | Bratislava,\nSlovakia</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Bangalore, India</strong></a>: June 6, 2025 | Bangalore, India</li>\n<li><a href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-china/\"><strong>KubeCon + CloudNativeCon China 2025</strong></a>: June\n10-11, 2025 | Hong Kong</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Antigua Guatemala, Guatemala</strong></a>: June 14, 2025 |\nAntigua Guatemala, Guatemala</li>\n<li><a href=\"https://events.linuxfoundation.org/kubecon-cloudnativecon-japan\"><strong>KubeCon + CloudNativeCon Japan 2025</strong></a>: June\n16-17, 2025 | Tokyo, Japan</li>\n<li><a href=\"https://www.cncf.io/kcds/\"><strong>KCD - Kubernetes Community Days: Nigeria, Africa</strong></a>: June 19, 2025 | Nigeria, Africa</li>\n</ul>\n<h2 id=\"upcoming-release-webinar\">Upcoming release webinar</h2>\n<p>Join members of the Kubernetes v1.32 release team on <strong>Thursday, January 9th 2025 at 5:00 PM (UTC)</strong>, to learn about the\nrelease highlights of this release, as well as deprecations and removals to help plan for upgrades.\nFor more information and registration, visit the <a href=\"https://community.cncf.io/events/details/cncf-cncf-online-programs-presents-cncf-live-webinar-kubernetes-132-release/\">event\npage</a>\non the CNCF Online Programs site.</p>\n<h2 id=\"get-involved\">Get involved</h2>\n<p>The simplest way to get involved with Kubernetes is by joining one of the many <a href=\"https://www.kubernetes.dev/community/community-groups/#special-interest-groups\">Special Interest\nGroups</a> (SIGs) that align with your\ninterests.\nHave something you’d like to broadcast to the Kubernetes community?\nShare your voice at our weekly <a href=\"https://github.com/kubernetes/community/tree/master/communication\">community meeting</a>,\nand through the channels below.\nThank you for your continued feedback and support.</p>\n<ul>\n<li>Follow us on Bluesky <a href=\"https://bsky.app/profile/did:plc:kyg4uikmq7lzpb76ugvxa6ul\">@Kubernetes.io</a> for latest updates</li>\n<li>Join the community discussion on <a href=\"https://discuss.kubernetes.io/\">Discuss</a></li>\n<li>Join the community on <a href=\"http://slack.k8s.io/\">Slack</a></li>\n<li>Post questions (or answer questions) on <a href=\"http://stackoverflow.com/questions/tagged/kubernetes\">Stack Overflow</a></li>\n<li>Share your Kubernetes\n<a href=\"https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform\">story</a></li>\n<li>Read more about what’s happening with Kubernetes on the <a href=\"https://kubernetes.io/blog/\">blog</a></li>\n<li>Learn more about the <a href=\"https://github.com/kubernetes/sig-release/tree/master/release-team\">Kubernetes Release Team</a></li>\n</ul>",
      "timestamp": 1741428556.9202433,
      "translated": false
    }
  ]
}